(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["ReactBootstrapTable2"] = factory(require("react"));
	else
		root["ReactBootstrapTable2"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (false) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(10)();
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  SORT_ASC: 'asc',
  SORT_DESC: 'desc',
  ROW_SELECT_SINGLE: 'radio',
  ROW_SELECT_MULTIPLE: 'checkbox',
  ROW_SELECT_DISABLED: 'ROW_SELECT_DISABLED',
  CHECKBOX_STATUS_CHECKED: 'checked',
  CHECKBOX_STATUS_INDETERMINATE: 'indeterminate',
  CHECKBOX_STATUS_UNCHECKED: 'unchecked'
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* eslint no-empty: 0 */
/* eslint no-param-reassign: 0 */
/* eslint prefer-rest-params: 0 */

function splitNested(str) {
  return [str].join('.').replace(/\[/g, '.').replace(/\]/g, '').split('.');
}

function get(target, field) {
  var pathArray = splitNested(field);
  var result = void 0;
  try {
    result = pathArray.reduce(function (curr, path) {
      return curr[path];
    }, target);
  } catch (e) {}
  return result;
}

function set(target, field, value) {
  var safe = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var pathArray = splitNested(field);
  var level = 0;
  pathArray.reduce(function (a, b) {
    level += 1;
    if (typeof a[b] === 'undefined') {
      if (!safe) throw new Error(a + '.' + b + ' is undefined');
      a[b] = {};
      return a[b];
    }

    if (level === pathArray.length) {
      a[b] = value;
      return value;
    }
    return a[b];
  }, target);
}

function isFunction(obj) {
  return obj && typeof obj === 'function';
}

/**
 * Checks if `value` is the Object. the `Object` except `Function` and `Array.`
 *
 * @param {*} obj - The value gonna check
 */
function isObject(obj) {
  var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
  return obj !== null && type === 'object' && obj.constructor === Object;
}

function isEmptyObject(obj) {
  if (!isObject(obj)) return false;

  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i += 1) {
    if (hasOwnProperty.call(obj, keys[i])) return false;
  }

  return true;
}

function isDefined(value) {
  return typeof value !== 'undefined' && value !== null;
}

function sleep(fn, ms) {
  return setTimeout(function () {
    return fn();
  }, ms);
}

function debounce(func, wait, immediate) {
  var _this = this,
      _arguments = arguments;

  var timeout = void 0;

  return function () {
    var later = function later() {
      timeout = null;

      if (!immediate) {
        func.apply(_this, _arguments);
      }
    };

    var callNow = immediate && !timeout;

    clearTimeout(timeout);
    timeout = setTimeout(later, wait || 0);

    if (callNow) {
      func.appy(_this, _arguments);
    }
  };
}

exports.default = {
  get: get,
  set: set,
  isFunction: isFunction,
  isObject: isObject,
  isEmptyObject: isEmptyObject,
  isDefined: isDefined,
  sleep: sleep,
  debounce: debounce
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BootstrapContext = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BootstrapContext = exports.BootstrapContext = _react2.default.createContext({
  bootstrap4: false
});

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return classNames;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var matchRow = exports.matchRow = function matchRow(keyField, id) {
  return function (row) {
    return row[keyField] === id;
  };
};

var getRowByRowId = exports.getRowByRowId = function getRowByRowId(data, keyField, id) {
  return data.find(matchRow(keyField, id));
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSelectedRows = exports.unSelectableKeys = exports.selectableKeys = exports.getSelectionSummary = undefined;

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _rows = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getSelectionSummary = exports.getSelectionSummary = function getSelectionSummary(data, keyField) {
  var selected = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  var allRowsSelected = true;
  var allRowsNotSelected = true;

  var rowKeys = data.map(function (d) {
    return d[keyField];
  });

  var _loop = function _loop(i) {
    var curr = rowKeys[i];
    if (typeof selected.find(function (x) {
      return x === curr;
    }) === 'undefined') {
      allRowsSelected = false;
    } else {
      allRowsNotSelected = false;
    }
  };

  for (var i = 0; i < rowKeys.length; i += 1) {
    _loop(i);
  }
  return {
    allRowsSelected: allRowsSelected,
    allRowsNotSelected: allRowsNotSelected
  };
};

var selectableKeys = exports.selectableKeys = function selectableKeys(data, keyField) {
  var skips = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (skips.length === 0) {
    return data.map(function (row) {
      return _utils2.default.get(row, keyField);
    });
  }
  return data.filter(function (row) {
    return !skips.includes(_utils2.default.get(row, keyField));
  }).map(function (row) {
    return _utils2.default.get(row, keyField);
  });
};

var unSelectableKeys = exports.unSelectableKeys = function unSelectableKeys(selected) {
  var skips = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (skips.length === 0) {
    return [];
  }
  return selected.filter(function (x) {
    return skips.includes(x);
  });
};

var getSelectedRows = exports.getSelectedRows = function getSelectedRows(data, keyField, selected) {
  return selected.map(function (k) {
    return (0, _rows.getRowByRowId)(data, keyField, k);
  });
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bootstrapTable = __webpack_require__(9);

var _bootstrapTable2 = _interopRequireDefault(_bootstrapTable);

var _contexts = __webpack_require__(32);

var _contexts2 = _interopRequireDefault(_contexts);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _contexts2.default)(_bootstrapTable2.default);

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(5);

var _classnames2 = _interopRequireDefault(_classnames);

var _header = __webpack_require__(14);

var _header2 = _interopRequireDefault(_header);

var _caption = __webpack_require__(20);

var _caption2 = _interopRequireDefault(_caption);

var _body = __webpack_require__(21);

var _body2 = _interopRequireDefault(_body);

var _propsResolver = __webpack_require__(29);

var _propsResolver2 = _interopRequireDefault(_propsResolver);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _selection = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint arrow-body-style: 0 */

var BootstrapTable = function (_PropsBaseResolver) {
  _inherits(BootstrapTable, _PropsBaseResolver);

  function BootstrapTable(props) {
    _classCallCheck(this, BootstrapTable);

    var _this = _possibleConstructorReturn(this, (BootstrapTable.__proto__ || Object.getPrototypeOf(BootstrapTable)).call(this, props));

    _this.validateProps();
    return _this;
  }

  _createClass(BootstrapTable, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          loading = _props.loading,
          overlay = _props.overlay;

      if (overlay) {
        var LoadingOverlay = overlay(loading);
        return _react2.default.createElement(
          LoadingOverlay,
          null,
          this.renderTable()
        );
      }
      return this.renderTable();
    }
  }, {
    key: 'renderTable',
    value: function renderTable() {
      var _props2 = this.props,
          data = _props2.data,
          columns = _props2.columns,
          keyField = _props2.keyField,
          id = _props2.id,
          classes = _props2.classes,
          striped = _props2.striped,
          hover = _props2.hover,
          bordered = _props2.bordered,
          condensed = _props2.condensed,
          noDataIndication = _props2.noDataIndication,
          caption = _props2.caption,
          rowStyle = _props2.rowStyle,
          rowClasses = _props2.rowClasses,
          wrapperClasses = _props2.wrapperClasses,
          rowEvents = _props2.rowEvents,
          selected = _props2.selected;


      var tableWrapperClass = (0, _classnames2.default)('react-bootstrap-table', wrapperClasses);

      var tableClass = (0, _classnames2.default)('table', {
        'table-striped': striped,
        'table-hover': hover,
        'table-bordered': bordered,
        'table-condensed': condensed
      }, classes);

      var cellSelectionInfo = this.resolveSelectRowProps({
        onRowSelect: this.props.onRowSelect
      });

      var _getSelectionSummary = (0, _selection.getSelectionSummary)(data, keyField, selected),
          allRowsSelected = _getSelectionSummary.allRowsSelected,
          allRowsNotSelected = _getSelectionSummary.allRowsNotSelected;

      var headerCellSelectionInfo = this.resolveSelectRowPropsForHeader({
        onAllRowsSelect: this.props.onAllRowsSelect,
        selected: selected,
        allRowsSelected: allRowsSelected,
        allRowsNotSelected: allRowsNotSelected
      });

      var tableCaption = caption && _react2.default.createElement(
        _caption2.default,
        null,
        caption
      );
      var expandRow = this.resolveExpandRowProps();

      return _react2.default.createElement(
        'div',
        { className: tableWrapperClass },
        _react2.default.createElement(
          'table',
          { id: id, className: tableClass },
          tableCaption,
          _react2.default.createElement(_header2.default, {
            columns: columns,
            className: this.props.headerClasses,
            sortField: this.props.sortField,
            sortOrder: this.props.sortOrder,
            onSort: this.props.onSort,
            onFilter: this.props.onFilter,
            onExternalFilter: this.props.onExternalFilter,
            selectRow: headerCellSelectionInfo,
            expandRow: expandRow
          }),
          _react2.default.createElement(_body2.default, {
            data: data,
            keyField: keyField,
            columns: columns,
            isEmpty: this.isEmpty(),
            visibleColumnSize: this.visibleColumnSize(),
            noDataIndication: noDataIndication,
            cellEdit: this.props.cellEdit || {},
            selectRow: cellSelectionInfo,
            selectedRowKeys: selected,
            expandRow: expandRow,
            rowStyle: rowStyle,
            rowClasses: rowClasses,
            rowEvents: rowEvents
          })
        )
      );
    }
  }]);

  return BootstrapTable;
}((0, _propsResolver2.default)(_react.Component));

BootstrapTable.propTypes = {
  keyField: _propTypes2.default.string.isRequired,
  data: _propTypes2.default.array.isRequired,
  columns: _propTypes2.default.array.isRequired,
  bootstrap4: _propTypes2.default.bool,
  remote: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.shape({
    pagination: _propTypes2.default.bool
  })]),
  noDataIndication: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
  striped: _propTypes2.default.bool,
  bordered: _propTypes2.default.bool,
  hover: _propTypes2.default.bool,
  id: _propTypes2.default.string,
  classes: _propTypes2.default.string,
  wrapperClasses: _propTypes2.default.string,
  condensed: _propTypes2.default.bool,
  caption: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.string]),
  pagination: _propTypes2.default.object,
  filter: _propTypes2.default.object,
  cellEdit: _propTypes2.default.object,
  selectRow: _propTypes2.default.shape({
    mode: _propTypes2.default.oneOf([_const2.default.ROW_SELECT_SINGLE, _const2.default.ROW_SELECT_MULTIPLE]).isRequired,
    clickToSelect: _propTypes2.default.bool,
    clickToEdit: _propTypes2.default.bool,
    onSelect: _propTypes2.default.func,
    onSelectAll: _propTypes2.default.func,
    style: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    classes: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    nonSelectable: _propTypes2.default.array,
    bgColor: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    hideSelectColumn: _propTypes2.default.bool,
    selectionRenderer: _propTypes2.default.func,
    selectionHeaderRenderer: _propTypes2.default.func
  }),
  onRowSelect: _propTypes2.default.func,
  onAllRowsSelect: _propTypes2.default.func,
  expandRow: _propTypes2.default.shape({
    renderer: _propTypes2.default.func.isRequired,
    expanded: _propTypes2.default.array,
    onExpand: _propTypes2.default.func,
    onExpandAll: _propTypes2.default.func,
    nonExpandable: _propTypes2.default.array,
    showExpandColumn: _propTypes2.default.bool,
    expandColumnRenderer: _propTypes2.default.func,
    expandHeaderColumnRenderer: _propTypes2.default.func
  }),
  onRowExpand: _propTypes2.default.func,
  onAllRowExpand: _propTypes2.default.func,
  isAnyExpands: _propTypes2.default.func,
  rowStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
  rowEvents: _propTypes2.default.object,
  rowClasses: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
  headerClasses: _propTypes2.default.string,
  defaultSorted: _propTypes2.default.arrayOf(_propTypes2.default.shape({
    dataField: _propTypes2.default.string.isRequired,
    order: _propTypes2.default.oneOf([_const2.default.SORT_DESC, _const2.default.SORT_ASC]).isRequired
  })),
  defaultSortDirection: _propTypes2.default.oneOf([_const2.default.SORT_DESC, _const2.default.SORT_ASC]),
  overlay: _propTypes2.default.func,
  onTableChange: _propTypes2.default.func,
  onSort: _propTypes2.default.func,
  onFilter: _propTypes2.default.func,
  onExternalFilter: _propTypes2.default.func,
  // Inject from toolkit
  search: _propTypes2.default.shape({
    searchText: _propTypes2.default.string,
    searchContext: _propTypes2.default.func
  }),
  setDependencyModules: _propTypes2.default.func
};

BootstrapTable.defaultProps = {
  bootstrap4: false,
  remote: false,
  striped: false,
  bordered: true,
  hover: false,
  condensed: false,
  noDataIndication: null
};

exports.default = BootstrapTable;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(11);
var invariant = __webpack_require__(12);
var ReactPropTypesSecret = __webpack_require__(13);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (false) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _headerCell = __webpack_require__(15);

var _headerCell2 = _interopRequireDefault(_headerCell);

var _selectionHeaderCell = __webpack_require__(18);

var _selectionHeaderCell2 = _interopRequireDefault(_selectionHeaderCell);

var _expandHeaderCell = __webpack_require__(19);

var _expandHeaderCell2 = _interopRequireDefault(_expandHeaderCell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint react/require-default-props: 0 */
var Header = function Header(props) {
  var ROW_SELECT_DISABLED = _const2.default.ROW_SELECT_DISABLED;
  var className = props.className,
      columns = props.columns,
      onSort = props.onSort,
      onFilter = props.onFilter,
      sortField = props.sortField,
      sortOrder = props.sortOrder,
      selectRow = props.selectRow,
      onExternalFilter = props.onExternalFilter,
      expandRow = props.expandRow,
      bootstrap4 = props.bootstrap4;


  return _react2.default.createElement(
    'thead',
    null,
    _react2.default.createElement(
      'tr',
      { className: className },
      expandRow && expandRow.showExpandColumn ? _react2.default.createElement(_expandHeaderCell2.default, {
        onAllRowExpand: expandRow.onAllRowExpand,
        anyExpands: expandRow.isAnyExpands,
        renderer: expandRow.expandHeaderColumnRenderer
      }) : null,
      selectRow.mode !== ROW_SELECT_DISABLED && !selectRow.hideSelectColumn ? _react2.default.createElement(_selectionHeaderCell2.default, selectRow) : null,
      columns.map(function (column, i) {
        if (!column.hidden) {
          var currSort = column.dataField === sortField;
          var isLastSorting = column.dataField === sortField;

          return _react2.default.createElement(_headerCell2.default, {
            index: i,
            bootstrap4: bootstrap4,
            key: column.dataField,
            column: column,
            onSort: onSort,
            sorting: currSort,
            onFilter: onFilter,
            onExternalFilter: onExternalFilter,
            sortOrder: sortOrder,
            isLastSorting: isLastSorting
          });
        }
        return false;
      })
    )
  );
};

Header.propTypes = {
  columns: _propTypes2.default.array.isRequired,
  onSort: _propTypes2.default.func,
  onFilter: _propTypes2.default.func,
  sortField: _propTypes2.default.string,
  sortOrder: _propTypes2.default.string,
  selectRow: _propTypes2.default.object,
  onExternalFilter: _propTypes2.default.func,
  className: _propTypes2.default.string,
  expandRow: _propTypes2.default.object,
  bootstrap4: _propTypes2.default.bool
};

exports.default = Header;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint react/require-default-props: 0 */


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(5);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _symbol = __webpack_require__(16);

var _symbol2 = _interopRequireDefault(_symbol);

var _caret = __webpack_require__(17);

var _caret2 = _interopRequireDefault(_caret);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HeaderCell = function HeaderCell(props) {
  var column = props.column,
      index = props.index,
      onSort = props.onSort,
      sorting = props.sorting,
      sortOrder = props.sortOrder,
      isLastSorting = props.isLastSorting,
      onFilter = props.onFilter,
      onExternalFilter = props.onExternalFilter;
  var text = column.text,
      sort = column.sort,
      filter = column.filter,
      filterRenderer = column.filterRenderer,
      headerTitle = column.headerTitle,
      headerAlign = column.headerAlign,
      headerFormatter = column.headerFormatter,
      headerEvents = column.headerEvents,
      headerClasses = column.headerClasses,
      headerStyle = column.headerStyle,
      headerAttrs = column.headerAttrs,
      headerSortingClasses = column.headerSortingClasses,
      headerSortingStyle = column.headerSortingStyle;


  var cellAttrs = _extends({}, _utils2.default.isFunction(headerAttrs) ? headerAttrs(column, index) : headerAttrs, headerEvents);

  var sortSymbol = void 0;
  var filterElm = void 0;
  var cellStyle = {};
  var cellClasses = _utils2.default.isFunction(headerClasses) ? headerClasses(column, index) : headerClasses;

  if (headerStyle) {
    cellStyle = _utils2.default.isFunction(headerStyle) ? headerStyle(column, index) : headerStyle;
  }

  if (headerTitle) {
    cellAttrs.title = _utils2.default.isFunction(headerTitle) ? headerTitle(column, index) : text;
  }

  if (headerAlign) {
    cellStyle.textAlign = _utils2.default.isFunction(headerAlign) ? headerAlign(column, index) : headerAlign;
  }

  if (sort) {
    var customClick = cellAttrs.onClick;
    cellAttrs.onClick = function (e) {
      onSort(column);
      if (_utils2.default.isFunction(customClick)) customClick(e);
    };
    cellAttrs.className = (0, _classnames2.default)(cellAttrs.className, 'sortable');

    if (sorting) {
      sortSymbol = _react2.default.createElement(_caret2.default, { order: sortOrder });

      // append customized classes or style if table was sorting based on the current column.
      cellClasses = (0, _classnames2.default)(cellClasses, _utils2.default.isFunction(headerSortingClasses) ? headerSortingClasses(column, sortOrder, isLastSorting, index) : headerSortingClasses);

      cellStyle = _extends({}, cellStyle, _utils2.default.isFunction(headerSortingStyle) ? headerSortingStyle(column, sortOrder, isLastSorting, index) : headerSortingStyle);
    } else {
      sortSymbol = _react2.default.createElement(_symbol2.default, null);
    }
  }

  if (cellClasses) cellAttrs.className = (0, _classnames2.default)(cellAttrs.className, cellClasses);
  if (!_utils2.default.isEmptyObject(cellStyle)) cellAttrs.style = cellStyle;

  if (filterRenderer) {
    var onCustomFilter = onExternalFilter(column, filter.props.type);
    filterElm = filterRenderer(onCustomFilter, column);
  } else if (filter) {
    filterElm = _react2.default.createElement(filter.Filter, _extends({}, filter.props, { onFilter: onFilter, column: column }));
  }

  var children = headerFormatter ? headerFormatter(column, index, { sortElement: sortSymbol, filterElement: filterElm }) : text;

  if (headerFormatter) {
    return _react2.default.createElement('th', cellAttrs, children);
  }

  return _react2.default.createElement('th', cellAttrs, children, sortSymbol, filterElm);
};

HeaderCell.propTypes = {
  column: _propTypes2.default.shape({
    dataField: _propTypes2.default.string.isRequired,
    text: _propTypes2.default.string.isRequired,
    hidden: _propTypes2.default.bool,
    headerFormatter: _propTypes2.default.func,
    formatter: _propTypes2.default.func,
    formatExtraData: _propTypes2.default.any,
    headerClasses: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    classes: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    headerStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    style: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    headerTitle: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.func]),
    title: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.func]),
    headerEvents: _propTypes2.default.object,
    events: _propTypes2.default.object,
    headerAlign: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    align: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    headerAttrs: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    attrs: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    sort: _propTypes2.default.bool,
    sortFunc: _propTypes2.default.func,
    onSort: _propTypes2.default.func,
    editor: _propTypes2.default.object,
    editable: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.func]),
    editCellStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    editCellClasses: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    editorStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    editorClasses: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    editorRenderer: _propTypes2.default.func,
    validator: _propTypes2.default.func,
    filter: _propTypes2.default.object,
    filterRenderer: _propTypes2.default.func,
    filterValue: _propTypes2.default.func
  }).isRequired,
  index: _propTypes2.default.number.isRequired,
  onSort: _propTypes2.default.func,
  sorting: _propTypes2.default.bool,
  sortOrder: _propTypes2.default.oneOf([_const2.default.SORT_ASC, _const2.default.SORT_DESC]),
  isLastSorting: _propTypes2.default.bool,
  onFilter: _propTypes2.default.func,
  onExternalFilter: _propTypes2.default.func
};

exports.default = HeaderCell;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _bootstrap = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SortSymbol = function SortSymbol() {
  return _react2.default.createElement(
    _bootstrap.BootstrapContext.Consumer,
    null,
    function (_ref) {
      var bootstrap4 = _ref.bootstrap4;
      return bootstrap4 ? _react2.default.createElement('span', { className: 'order-4' }) : _react2.default.createElement(
        'span',
        { className: 'order' },
        _react2.default.createElement(
          'span',
          { className: 'dropdown' },
          _react2.default.createElement('span', { className: 'caret' })
        ),
        _react2.default.createElement(
          'span',
          { className: 'dropup' },
          _react2.default.createElement('span', { className: 'caret' })
        )
      );
    }
  );
};

exports.default = SortSymbol;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(5);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _bootstrap = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SortCaret = function SortCaret(_ref) {
  var order = _ref.order;

  var orderClass = (0, _classnames2.default)('react-bootstrap-table-sort-order', {
    dropup: order === _const2.default.SORT_ASC
  });

  return _react2.default.createElement(
    _bootstrap.BootstrapContext.Consumer,
    null,
    function (_ref2) {
      var bootstrap4 = _ref2.bootstrap4;
      return bootstrap4 ? _react2.default.createElement('span', { className: 'caret-4-' + order }) : _react2.default.createElement(
        'span',
        { className: orderClass },
        _react2.default.createElement('span', { className: 'caret' })
      );
    }
  );
};

SortCaret.propTypes = {
  order: _propTypes2.default.oneOf([_const2.default.SORT_ASC, _const2.default.SORT_DESC]).isRequired
};

exports.default = SortCaret;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CheckBox = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _bootstrap = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */


var CheckBox = exports.CheckBox = function CheckBox(_ref) {
  var className = _ref.className,
      checked = _ref.checked,
      indeterminate = _ref.indeterminate;
  return _react2.default.createElement('input', {
    type: 'checkbox',
    checked: checked,
    className: className,
    ref: function ref(input) {
      if (input) input.indeterminate = indeterminate; // eslint-disable-line no-param-reassign
    }
  });
};

CheckBox.propTypes = {
  checked: _propTypes2.default.bool.isRequired,
  indeterminate: _propTypes2.default.bool.isRequired,
  className: _propTypes2.default.string
};

var SelectionHeaderCell = function (_Component) {
  _inherits(SelectionHeaderCell, _Component);

  function SelectionHeaderCell() {
    _classCallCheck(this, SelectionHeaderCell);

    var _this = _possibleConstructorReturn(this, (SelectionHeaderCell.__proto__ || Object.getPrototypeOf(SelectionHeaderCell)).call(this));

    _this.handleCheckBoxClick = _this.handleCheckBoxClick.bind(_this);
    return _this;
  }

  /**
   * avoid updating if button is
   * 1. radio
   * 2. status was not changed.
   */


  _createClass(SelectionHeaderCell, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps) {
      var ROW_SELECT_SINGLE = _const2.default.ROW_SELECT_SINGLE;
      var _props = this.props,
          mode = _props.mode,
          checkedStatus = _props.checkedStatus;


      if (mode === ROW_SELECT_SINGLE) return false;

      return nextProps.checkedStatus !== checkedStatus;
    }
  }, {
    key: 'handleCheckBoxClick',
    value: function handleCheckBoxClick(e) {
      var _props2 = this.props,
          onAllRowsSelect = _props2.onAllRowsSelect,
          checkedStatus = _props2.checkedStatus;

      var isUnSelect = checkedStatus === _const2.default.CHECKBOX_STATUS_CHECKED || checkedStatus === _const2.default.CHECKBOX_STATUS_INDETERMINATE;

      onAllRowsSelect(e, isUnSelect);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var CHECKBOX_STATUS_CHECKED = _const2.default.CHECKBOX_STATUS_CHECKED,
          CHECKBOX_STATUS_INDETERMINATE = _const2.default.CHECKBOX_STATUS_INDETERMINATE,
          ROW_SELECT_MULTIPLE = _const2.default.ROW_SELECT_MULTIPLE;
      var _props3 = this.props,
          mode = _props3.mode,
          checkedStatus = _props3.checkedStatus,
          selectionHeaderRenderer = _props3.selectionHeaderRenderer;


      var checked = checkedStatus === CHECKBOX_STATUS_CHECKED;

      var indeterminate = checkedStatus === CHECKBOX_STATUS_INDETERMINATE;

      var attrs = {};
      var content = void 0;
      if (selectionHeaderRenderer || mode === ROW_SELECT_MULTIPLE) {
        attrs.onClick = this.handleCheckBoxClick;
      }

      return _react2.default.createElement(
        _bootstrap.BootstrapContext.Consumer,
        null,
        function (_ref2) {
          var bootstrap4 = _ref2.bootstrap4;

          if (selectionHeaderRenderer) {
            content = selectionHeaderRenderer({
              mode: mode,
              checked: checked,
              indeterminate: indeterminate
            });
          } else if (mode === ROW_SELECT_MULTIPLE) {
            content = _react2.default.createElement(CheckBox, _extends({}, _this2.props, {
              checked: checked,
              className: bootstrap4 ? 'selection-input-4' : '',
              indeterminate: indeterminate
            }));
          }
          return _react2.default.createElement(
            'th',
            _extends({ 'data-row-selection': true }, attrs),
            content
          );
        }
      );
    }
  }]);

  return SelectionHeaderCell;
}(_react.Component);

SelectionHeaderCell.propTypes = {
  mode: _propTypes2.default.string.isRequired,
  checkedStatus: _propTypes2.default.string,
  onAllRowsSelect: _propTypes2.default.func,
  selectionHeaderRenderer: _propTypes2.default.func
};
exports.default = SelectionHeaderCell;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */
/* eslint no-nested-ternary: 0 */


var SelectionHeaderCell = function (_Component) {
  _inherits(SelectionHeaderCell, _Component);

  function SelectionHeaderCell() {
    _classCallCheck(this, SelectionHeaderCell);

    var _this = _possibleConstructorReturn(this, (SelectionHeaderCell.__proto__ || Object.getPrototypeOf(SelectionHeaderCell)).call(this));

    _this.handleCheckBoxClick = _this.handleCheckBoxClick.bind(_this);
    return _this;
  }

  _createClass(SelectionHeaderCell, [{
    key: 'handleCheckBoxClick',
    value: function handleCheckBoxClick(e) {
      var _props = this.props,
          anyExpands = _props.anyExpands,
          onAllRowExpand = _props.onAllRowExpand;


      onAllRowExpand(e, !anyExpands);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          anyExpands = _props2.anyExpands,
          renderer = _props2.renderer;

      var attrs = {
        onClick: this.handleCheckBoxClick
      };

      return _react2.default.createElement(
        'th',
        _extends({ 'data-row-selection': true }, attrs),
        renderer ? renderer({ isAnyExpands: anyExpands }) : anyExpands ? '(-)' : '(+)'
      );
    }
  }]);

  return SelectionHeaderCell;
}(_react.Component);

SelectionHeaderCell.propTypes = {
  anyExpands: _propTypes2.default.bool.isRequired,
  onAllRowExpand: _propTypes2.default.func.isRequired,
  renderer: _propTypes2.default.func
};
exports.default = SelectionHeaderCell;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint react/require-default-props: 0 */
var Caption = function Caption(props) {
  if (!props.children) return null;
  return _react2.default.createElement(
    'caption',
    null,
    props.children
  );
};

Caption.propTypes = {
  children: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.string])
};

exports.default = Caption;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint react/prop-types: 0 */
/* eslint react/require-default-props: 0 */

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(5);

var _classnames2 = _interopRequireDefault(_classnames);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _row = __webpack_require__(22);

var _row2 = _interopRequireDefault(_row);

var _expandRow = __webpack_require__(27);

var _expandRow2 = _interopRequireDefault(_expandRow);

var _rowSection = __webpack_require__(28);

var _rowSection2 = _interopRequireDefault(_rowSection);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Body = function Body(props) {
  var columns = props.columns,
      data = props.data,
      keyField = props.keyField,
      isEmpty = props.isEmpty,
      noDataIndication = props.noDataIndication,
      visibleColumnSize = props.visibleColumnSize,
      cellEdit = props.cellEdit,
      selectRow = props.selectRow,
      selectedRowKeys = props.selectedRowKeys,
      rowStyle = props.rowStyle,
      rowClasses = props.rowClasses,
      rowEvents = props.rowEvents,
      expandRow = props.expandRow;
  var bgColor = selectRow.bgColor,
      nonSelectable = selectRow.nonSelectable;


  var content = void 0;

  if (isEmpty) {
    var indication = _utils2.default.isFunction(noDataIndication) ? noDataIndication() : noDataIndication;
    if (!indication) {
      return null;
    }
    content = _react2.default.createElement(_rowSection2.default, { content: indication, colSpan: visibleColumnSize });
  } else {
    var nonEditableRows = cellEdit.nonEditableRows || [];
    content = data.map(function (row, index) {
      var key = _utils2.default.get(row, keyField);
      var editable = !(nonEditableRows.length > 0 && nonEditableRows.indexOf(key) > -1);

      var selected = selectRow.mode !== _const2.default.ROW_SELECT_DISABLED ? selectedRowKeys.includes(key) : null;

      var attrs = rowEvents || {};
      var style = _utils2.default.isFunction(rowStyle) ? rowStyle(row, index) : rowStyle;
      var classes = _utils2.default.isFunction(rowClasses) ? rowClasses(row, index) : rowClasses;
      if (selected) {
        var selectedStyle = _utils2.default.isFunction(selectRow.style) ? selectRow.style(row, index) : selectRow.style;

        var selectedClasses = _utils2.default.isFunction(selectRow.classes) ? selectRow.classes(row, index) : selectRow.classes;

        style = _extends({}, style, selectedStyle);
        classes = (0, _classnames2.default)(classes, selectedClasses);

        if (bgColor) {
          style = style || {};
          style.backgroundColor = _utils2.default.isFunction(bgColor) ? bgColor(row, index) : bgColor;
        }
      }

      var selectable = !nonSelectable || !nonSelectable.includes(key);
      var expandable = expandRow && !expandRow.nonExpandable.includes(key);
      var expanded = expandRow && expandRow.expanded.includes(key);

      var result = [_react2.default.createElement(_row2.default, {
        key: key,
        row: row,
        keyField: keyField,
        rowIndex: index,
        columns: columns,
        cellEdit: cellEdit,
        editable: editable,
        selectable: selectable,
        expandable: expandable,
        selected: selected,
        expanded: expanded,
        selectRow: selectRow,
        expandRow: expandRow,
        style: style,
        className: classes,
        attrs: attrs
      })];

      if (expanded) {
        result.push(_react2.default.createElement(
          _expandRow2.default,
          {
            key: key + '-expanding',
            colSpan: visibleColumnSize
          },
          expandRow.renderer(row)
        ));
      }

      return result;
    });
  }

  return _react2.default.createElement(
    'tbody',
    null,
    content
  );
};

Body.propTypes = {
  keyField: _propTypes2.default.string.isRequired,
  data: _propTypes2.default.array.isRequired,
  columns: _propTypes2.default.array.isRequired,
  selectRow: _propTypes2.default.object,
  selectedRowKeys: _propTypes2.default.array
};

exports.default = Body;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _cell = __webpack_require__(23);

var _cell2 = _interopRequireDefault(_cell);

var _selectionCell = __webpack_require__(24);

var _selectionCell2 = _interopRequireDefault(_selectionCell);

var _expandCell = __webpack_require__(25);

var _expandCell2 = _interopRequireDefault(_expandCell);

var _rowEventDelegater = __webpack_require__(26);

var _rowEventDelegater2 = _interopRequireDefault(_rowEventDelegater);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */
/* eslint react/no-array-index-key: 0 */


var Row = function (_eventDelegater) {
  _inherits(Row, _eventDelegater);

  function Row() {
    _classCallCheck(this, Row);

    return _possibleConstructorReturn(this, (Row.__proto__ || Object.getPrototypeOf(Row)).apply(this, arguments));
  }

  _createClass(Row, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          row = _props.row,
          columns = _props.columns,
          keyField = _props.keyField,
          rowIndex = _props.rowIndex,
          className = _props.className,
          style = _props.style,
          attrs = _props.attrs,
          cellEdit = _props.cellEdit,
          selected = _props.selected,
          selectRow = _props.selectRow,
          expanded = _props.expanded,
          expandRow = _props.expandRow,
          selectable = _props.selectable,
          editableRow = _props.editable;

      var mode = cellEdit.mode,
          onStart = cellEdit.onStart,
          EditingCell = cellEdit.EditingCell,
          editingRowIdx = cellEdit.ridx,
          editingColIdx = cellEdit.cidx,
          CLICK_TO_CELL_EDIT = cellEdit.CLICK_TO_CELL_EDIT,
          DBCLICK_TO_CELL_EDIT = cellEdit.DBCLICK_TO_CELL_EDIT,
          rest = _objectWithoutProperties(cellEdit, ['mode', 'onStart', 'EditingCell', 'ridx', 'cidx', 'CLICK_TO_CELL_EDIT', 'DBCLICK_TO_CELL_EDIT']);

      var key = _utils2.default.get(row, keyField);
      var hideSelectColumn = selectRow.hideSelectColumn;

      var _ref = expandRow || {},
          showExpandColumn = _ref.showExpandColumn;

      var trAttrs = this.delegate(attrs);

      return _react2.default.createElement(
        'tr',
        _extends({ style: style, className: className }, trAttrs),
        showExpandColumn ? _react2.default.createElement(_expandCell2.default, _extends({}, expandRow, {
          rowKey: key,
          rowIndex: rowIndex,
          expanded: expanded
        })) : null,
        selectRow.mode !== _const2.default.ROW_SELECT_DISABLED && !hideSelectColumn ? _react2.default.createElement(_selectionCell2.default, _extends({}, selectRow, {
          rowKey: key,
          rowIndex: rowIndex,
          selected: selected,
          disabled: !selectable
        })) : null,
        columns.map(function (column, index) {
          if (!column.hidden) {
            var dataField = column.dataField;

            var content = _utils2.default.get(row, dataField);
            var editable = _utils2.default.isDefined(column.editable) ? column.editable : true;
            if (dataField === keyField || !editableRow) editable = false;
            if (_utils2.default.isFunction(column.editable)) {
              editable = column.editable(content, row, rowIndex, index);
            }
            if (rowIndex === editingRowIdx && index === editingColIdx) {
              var editCellstyle = column.editCellStyle || {};
              var editCellclasses = column.editCellClasses;
              if (_utils2.default.isFunction(column.editCellStyle)) {
                editCellstyle = column.editCellStyle(content, row, rowIndex, index);
              }
              if (_utils2.default.isFunction(column.editCellClasses)) {
                editCellclasses = column.editCellClasses(content, row, rowIndex, index);
              }
              return _react2.default.createElement(EditingCell, _extends({
                key: content + '-' + index,
                row: row,
                rowIndex: rowIndex,
                column: column,
                columnIndex: index,
                className: editCellclasses,
                style: editCellstyle
              }, rest));
            }
            return _react2.default.createElement(_cell2.default, {
              key: content + '-' + index,
              row: row,
              rowIndex: rowIndex,
              columnIndex: index,
              column: column,
              onStart: onStart,
              editable: editable,
              clickToEdit: mode === CLICK_TO_CELL_EDIT,
              dbclickToEdit: mode === DBCLICK_TO_CELL_EDIT
            });
          }
          return false;
        })
      );
    }
  }]);

  return Row;
}((0, _rowEventDelegater2.default)(_react.Component));

Row.propTypes = {
  row: _propTypes2.default.object.isRequired,
  rowIndex: _propTypes2.default.number.isRequired,
  columns: _propTypes2.default.array.isRequired,
  style: _propTypes2.default.object,
  className: _propTypes2.default.string,
  attrs: _propTypes2.default.object
};

Row.defaultProps = {
  editable: true,
  style: {},
  className: null,
  attrs: {}
};

exports.default = Row;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */


var Cell = function (_Component) {
  _inherits(Cell, _Component);

  function Cell(props) {
    _classCallCheck(this, Cell);

    var _this = _possibleConstructorReturn(this, (Cell.__proto__ || Object.getPrototypeOf(Cell)).call(this, props));

    _this.handleEditingCell = _this.handleEditingCell.bind(_this);
    return _this;
  }

  _createClass(Cell, [{
    key: 'handleEditingCell',
    value: function handleEditingCell(e) {
      var _props = this.props,
          column = _props.column,
          onStart = _props.onStart,
          rowIndex = _props.rowIndex,
          columnIndex = _props.columnIndex,
          clickToEdit = _props.clickToEdit,
          dbclickToEdit = _props.dbclickToEdit;
      var events = column.events;

      if (events) {
        if (clickToEdit) {
          var customClick = events.onClick;
          if (_utils2.default.isFunction(customClick)) customClick(e);
        } else if (dbclickToEdit) {
          var customDbClick = events.onDoubleClick;
          if (_utils2.default.isFunction(customDbClick)) customDbClick(e);
        }
      }
      if (onStart) {
        onStart(rowIndex, columnIndex);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          row = _props2.row,
          rowIndex = _props2.rowIndex,
          column = _props2.column,
          columnIndex = _props2.columnIndex,
          editable = _props2.editable,
          clickToEdit = _props2.clickToEdit,
          dbclickToEdit = _props2.dbclickToEdit;
      var dataField = column.dataField,
          formatter = column.formatter,
          formatExtraData = column.formatExtraData,
          style = column.style,
          classes = column.classes,
          title = column.title,
          events = column.events,
          align = column.align,
          attrs = column.attrs;

      var cellTitle = void 0;
      var cellStyle = {};
      var content = _utils2.default.get(row, dataField);

      var cellAttrs = _extends({}, _utils2.default.isFunction(attrs) ? attrs(content, row, rowIndex, columnIndex) : attrs, events);

      var cellClasses = _utils2.default.isFunction(classes) ? classes(content, row, rowIndex, columnIndex) : classes;

      if (style) {
        cellStyle = _utils2.default.isFunction(style) ? style(content, row, rowIndex, columnIndex) : style;
      }

      if (title) {
        cellTitle = _utils2.default.isFunction(title) ? title(content, row, rowIndex, columnIndex) : content;
        cellAttrs.title = cellTitle;
      }

      if (formatter) {
        content = column.formatter(content, row, rowIndex, formatExtraData);
      }

      if (align) {
        cellStyle.textAlign = _utils2.default.isFunction(align) ? align(content, row, rowIndex, columnIndex) : align;
      }

      if (cellClasses) cellAttrs.className = cellClasses;

      if (!_utils2.default.isEmptyObject(cellStyle)) cellAttrs.style = cellStyle;
      if (clickToEdit && editable) {
        cellAttrs.onClick = this.handleEditingCell;
      } else if (dbclickToEdit && editable) {
        cellAttrs.onDoubleClick = this.handleEditingCell;
      }
      return _react2.default.createElement(
        'td',
        cellAttrs,
        typeof content === 'boolean' ? '' + content : content
      );
    }
  }]);

  return Cell;
}(_react.Component);

Cell.propTypes = {
  row: _propTypes2.default.object.isRequired,
  rowIndex: _propTypes2.default.number.isRequired,
  column: _propTypes2.default.object.isRequired,
  columnIndex: _propTypes2.default.number.isRequired
};

exports.default = Cell;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _bootstrap = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 react/require-default-props: 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 jsx-a11y/no-noninteractive-element-interactions: 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */


var SelectionCell = function (_Component) {
  _inherits(SelectionCell, _Component);

  function SelectionCell() {
    _classCallCheck(this, SelectionCell);

    var _this = _possibleConstructorReturn(this, (SelectionCell.__proto__ || Object.getPrototypeOf(SelectionCell)).call(this));

    _this.handleClick = _this.handleClick.bind(_this);
    return _this;
  }

  _createClass(SelectionCell, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps) {
      var selected = this.props.selected;


      return nextProps.selected !== selected;
    }
  }, {
    key: 'handleClick',
    value: function handleClick(e) {
      var _props = this.props,
          inputType = _props.mode,
          rowKey = _props.rowKey,
          selected = _props.selected,
          onRowSelect = _props.onRowSelect,
          disabled = _props.disabled,
          rowIndex = _props.rowIndex,
          clickToSelect = _props.clickToSelect;


      if (disabled) return;
      if (clickToSelect) return;

      var checked = inputType === _const2.default.ROW_SELECT_SINGLE ? true : !selected;

      onRowSelect(rowKey, checked, rowIndex, e);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props2 = this.props,
          inputType = _props2.mode,
          selected = _props2.selected,
          disabled = _props2.disabled,
          selectionRenderer = _props2.selectionRenderer;


      return _react2.default.createElement(
        _bootstrap.BootstrapContext.Consumer,
        null,
        function (_ref) {
          var bootstrap4 = _ref.bootstrap4;
          return _react2.default.createElement(
            'td',
            { onClick: _this2.handleClick },
            selectionRenderer ? selectionRenderer({
              mode: inputType,
              checked: selected,
              disabled: disabled
            }) : _react2.default.createElement('input', {
              type: inputType,
              checked: selected,
              disabled: disabled,
              className: bootstrap4 ? 'selection-input-4' : ''
            })
          );
        }
      );
    }
  }]);

  return SelectionCell;
}(_react.Component);

SelectionCell.propTypes = {
  mode: _propTypes2.default.string.isRequired,
  rowKey: _propTypes2.default.any,
  selected: _propTypes2.default.bool,
  onRowSelect: _propTypes2.default.func,
  disabled: _propTypes2.default.bool,
  rowIndex: _propTypes2.default.number,
  clickToSelect: _propTypes2.default.bool,
  selectionRenderer: _propTypes2.default.func
};
exports.default = SelectionCell;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 react/require-default-props: 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 jsx-a11y/no-noninteractive-element-interactions: 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */
/* eslint no-nested-ternary: 0 */


var ExpandCell = function (_Component) {
  _inherits(ExpandCell, _Component);

  function ExpandCell() {
    _classCallCheck(this, ExpandCell);

    var _this = _possibleConstructorReturn(this, (ExpandCell.__proto__ || Object.getPrototypeOf(ExpandCell)).call(this));

    _this.handleClick = _this.handleClick.bind(_this);
    return _this;
  }

  _createClass(ExpandCell, [{
    key: 'handleClick',
    value: function handleClick(e) {
      var _props = this.props,
          rowKey = _props.rowKey,
          expanded = _props.expanded,
          onRowExpand = _props.onRowExpand,
          rowIndex = _props.rowIndex;


      onRowExpand(rowKey, expanded, rowIndex, e);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          expanded = _props2.expanded,
          expandColumnRenderer = _props2.expandColumnRenderer;


      return _react2.default.createElement(
        'td',
        { onClick: this.handleClick },
        expandColumnRenderer ? expandColumnRenderer({
          expanded: expanded
        }) : expanded ? '(-)' : '(+)'
      );
    }
  }]);

  return ExpandCell;
}(_react.Component);

ExpandCell.propTypes = {
  rowKey: _propTypes2.default.any,
  expanded: _propTypes2.default.bool.isRequired,
  onRowExpand: _propTypes2.default.func.isRequired,
  expandColumnRenderer: _propTypes2.default.func,
  rowIndex: _propTypes2.default.number
};
exports.default = ExpandCell;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var events = ['onClick', 'onDoubleClick', 'onMouseEnter', 'onMouseLeave'];

exports.default = function (ExtendBase) {
  return function (_ExtendBase) {
    _inherits(RowEventDelegater, _ExtendBase);

    function RowEventDelegater(props) {
      _classCallCheck(this, RowEventDelegater);

      var _this = _possibleConstructorReturn(this, (RowEventDelegater.__proto__ || Object.getPrototypeOf(RowEventDelegater)).call(this, props));

      _this.clickNum = 0;
      _this.createDefaultEventHandler = _this.createDefaultEventHandler.bind(_this);
      _this.createClickEventHandler = _this.createClickEventHandler.bind(_this);
      return _this;
    }

    _createClass(RowEventDelegater, [{
      key: 'createDefaultEventHandler',
      value: function createDefaultEventHandler(cb) {
        var _this2 = this;

        return function (e) {
          var _props = _this2.props,
              row = _props.row,
              rowIndex = _props.rowIndex;

          cb(e, row, rowIndex);
        };
      }
    }, {
      key: 'createClickEventHandler',
      value: function createClickEventHandler(cb) {
        var _this3 = this;

        return function (e) {
          var _props2 = _this3.props,
              row = _props2.row,
              selected = _props2.selected,
              keyField = _props2.keyField,
              selectable = _props2.selectable,
              expandable = _props2.expandable,
              rowIndex = _props2.rowIndex,
              expanded = _props2.expanded,
              expandRow = _props2.expandRow,
              selectRow = _props2.selectRow,
              _props2$cellEdit = _props2.cellEdit,
              mode = _props2$cellEdit.mode,
              DBCLICK_TO_CELL_EDIT = _props2$cellEdit.DBCLICK_TO_CELL_EDIT,
              DELAY_FOR_DBCLICK = _props2$cellEdit.DELAY_FOR_DBCLICK;


          var clickFn = function clickFn() {
            if (cb) {
              cb(e, row, rowIndex);
            }
            var key = _utils2.default.get(row, keyField);
            if (expandRow && expandable) {
              expandRow.onRowExpand(key, !expanded, rowIndex, e);
            }
            if (selectRow.mode !== _const2.default.ROW_SELECT_DISABLED && selectable) {
              selectRow.onRowSelect(key, !selected, rowIndex, e);
            }
          };

          if (mode === DBCLICK_TO_CELL_EDIT && selectRow.clickToEdit) {
            _this3.clickNum += 1;
            _utils2.default.debounce(function () {
              if (_this3.clickNum === 1) {
                clickFn();
              }
              _this3.clickNum = 0;
            }, DELAY_FOR_DBCLICK)();
          } else {
            clickFn();
          }
        };
      }
    }, {
      key: 'delegate',
      value: function delegate() {
        var _this4 = this;

        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var newAttrs = {};
        var _props3 = this.props,
            expandRow = _props3.expandRow,
            selectRow = _props3.selectRow;

        if (expandRow || selectRow && selectRow.clickToSelect) {
          newAttrs.onClick = this.createClickEventHandler(attrs.onClick);
        }
        Object.keys(attrs).forEach(function (attr) {
          if (!newAttrs[attr]) {
            if (events.includes(attr)) {
              newAttrs[attr] = _this4.createDefaultEventHandler(attrs[attr]);
            } else {
              newAttrs[attr] = attrs[attr];
            }
          }
        });
        return newAttrs;
      }
    }]);

    return RowEventDelegater;
  }(ExtendBase);
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var ExpandRow = function ExpandRow(_ref) {
  var children = _ref.children,
      rest = _objectWithoutProperties(_ref, ['children']);

  return _react2.default.createElement(
    'tr',
    { className: 'expanding-row' },
    _react2.default.createElement(
      'td',
      rest,
      children
    )
  );
};

ExpandRow.propTypes = {
  children: _propTypes2.default.node
};

ExpandRow.defaultProps = {
  children: null
};

exports.default = ExpandRow;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RowSection = function RowSection(_ref) {
  var content = _ref.content,
      colSpan = _ref.colSpan;
  return _react2.default.createElement(
    'tr',
    null,
    _react2.default.createElement(
      'td',
      {
        'data-toggle': 'collapse',
        colSpan: colSpan,
        className: 'react-bs-table-no-data'
      },
      content
    )
  );
};

RowSection.propTypes = {
  content: _propTypes2.default.any,
  colSpan: _propTypes2.default.number
};

RowSection.defaultProps = {
  content: null,
  colSpan: 1
};

exports.default = RowSection;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _columnResolver = __webpack_require__(30);

var _columnResolver2 = _interopRequireDefault(_columnResolver);

var _expandRowResolver = __webpack_require__(31);

var _expandRowResolver2 = _interopRequireDefault(_expandRowResolver);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = function (ExtendBase) {
  return function (_ExpandRowResolver) {
    _inherits(TableResolver, _ExpandRowResolver);

    function TableResolver() {
      _classCallCheck(this, TableResolver);

      return _possibleConstructorReturn(this, (TableResolver.__proto__ || Object.getPrototypeOf(TableResolver)).apply(this, arguments));
    }

    _createClass(TableResolver, [{
      key: 'validateProps',
      value: function validateProps() {
        var keyField = this.props.keyField;

        if (!keyField) {
          throw new Error('Please specify a field as key via keyField');
        }
        if (this.visibleColumnSize(false) <= 0) {
          throw new Error('No visible columns detected');
        }
      }
    }, {
      key: 'isEmpty',
      value: function isEmpty() {
        return this.props.data.length === 0;
      }

      /**
       * props resolver for cell selection
       * @param {Object} options - addtional options like callback which are about to merge into props
       *
       * @returns {Object} result - props for cell selections
       * @returns {String} result.mode - input type of row selection or disabled.
       */

    }, {
      key: 'resolveSelectRowProps',
      value: function resolveSelectRowProps(options) {
        var selectRow = this.props.selectRow;
        var ROW_SELECT_DISABLED = _const2.default.ROW_SELECT_DISABLED;


        if (_utils2.default.isDefined(selectRow)) {
          return _extends({}, selectRow, options);
        }

        return {
          mode: ROW_SELECT_DISABLED
        };
      }

      /**
       * props resolver for header cell selection
       * @param {Object} options - addtional options like callback which are about to merge into props
       *
       * @returns {Object} result - props for cell selections
       * @returns {String} result.mode - input type of row selection or disabled.
       * @returns {String} result.checkedStatus - checkbox status depending on selected rows counts
       */

    }, {
      key: 'resolveSelectRowPropsForHeader',
      value: function resolveSelectRowPropsForHeader() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var selectRow = this.props.selectRow;

        var allRowsSelected = options.allRowsSelected,
            allRowsNotSelected = options.allRowsNotSelected,
            rest = _objectWithoutProperties(options, ['allRowsSelected', 'allRowsNotSelected']);

        var ROW_SELECT_DISABLED = _const2.default.ROW_SELECT_DISABLED,
            CHECKBOX_STATUS_CHECKED = _const2.default.CHECKBOX_STATUS_CHECKED,
            CHECKBOX_STATUS_INDETERMINATE = _const2.default.CHECKBOX_STATUS_INDETERMINATE,
            CHECKBOX_STATUS_UNCHECKED = _const2.default.CHECKBOX_STATUS_UNCHECKED;


        if (_utils2.default.isDefined(selectRow)) {
          var checkedStatus = void 0;

          // checkbox status depending on selected rows counts
          if (allRowsSelected) checkedStatus = CHECKBOX_STATUS_CHECKED;else if (allRowsNotSelected) checkedStatus = CHECKBOX_STATUS_UNCHECKED;else checkedStatus = CHECKBOX_STATUS_INDETERMINATE;

          return _extends({}, selectRow, rest, {
            checkedStatus: checkedStatus
          });
        }

        return {
          mode: ROW_SELECT_DISABLED
        };
      }
    }]);

    return TableResolver;
  }((0, _expandRowResolver2.default)((0, _columnResolver2.default)(ExtendBase)));
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = function (ExtendBase) {
  return function (_ExtendBase) {
    _inherits(ColumnResolver, _ExtendBase);

    function ColumnResolver() {
      _classCallCheck(this, ColumnResolver);

      return _possibleConstructorReturn(this, (ColumnResolver.__proto__ || Object.getPrototypeOf(ColumnResolver)).apply(this, arguments));
    }

    _createClass(ColumnResolver, [{
      key: "visibleColumnSize",
      value: function visibleColumnSize() {
        var includeSelectColumn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        var columnLen = this.props.columns.filter(function (c) {
          return !c.hidden;
        }).length;
        if (!includeSelectColumn) return columnLen;
        if (this.props.selectRow && !this.props.selectRow.hideSelectColumn) {
          columnLen += 1;
        }
        if (this.props.expandRow && this.props.expandRow.showExpandColumn) {
          columnLen += 1;
        }
        return columnLen;
      }
    }]);

    return ColumnResolver;
  }(ExtendBase);
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = function (ExtendBase) {
  return function (_ExtendBase) {
    _inherits(ExpandRowResolver, _ExtendBase);

    function ExpandRowResolver() {
      _classCallCheck(this, ExpandRowResolver);

      return _possibleConstructorReturn(this, (ExpandRowResolver.__proto__ || Object.getPrototypeOf(ExpandRowResolver)).apply(this, arguments));
    }

    _createClass(ExpandRowResolver, [{
      key: "resolveExpandRowProps",
      value: function resolveExpandRowProps() {
        var _props = this.props,
            expandRow = _props.expandRow,
            expanded = _props.expanded,
            onRowExpand = _props.onRowExpand,
            onAllRowExpand = _props.onAllRowExpand,
            isAnyExpands = _props.isAnyExpands;

        if (expandRow) {
          return _extends({}, expandRow, {
            expanded: expanded,
            onRowExpand: onRowExpand,
            onAllRowExpand: onAllRowExpand,
            isAnyExpands: isAnyExpands,
            nonExpandable: expandRow.nonExpandable || []
          });
        }
        return null;
      }
    }]);

    return ExpandRowResolver;
  }(ExtendBase);
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _dataContext = __webpack_require__(33);

var _dataContext2 = _interopRequireDefault(_dataContext);

var _sortContext = __webpack_require__(34);

var _sortContext2 = _interopRequireDefault(_sortContext);

var _selectionContext = __webpack_require__(35);

var _selectionContext2 = _interopRequireDefault(_selectionContext);

var _rowExpandContext = __webpack_require__(36);

var _rowExpandContext2 = _interopRequireDefault(_rowExpandContext);

var _remoteResolver2 = __webpack_require__(37);

var _remoteResolver3 = _interopRequireDefault(_remoteResolver2);

var _bootstrap = __webpack_require__(4);

var _operators = __webpack_require__(38);

var _operators2 = _interopRequireDefault(_operators);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-return-assign: 0 */
/* eslint class-methods-use-this: 0 */


var withContext = function withContext(Base) {
  return function (_remoteResolver) {
    _inherits(BootstrapTableContainer, _remoteResolver);

    function BootstrapTableContainer(props) {
      _classCallCheck(this, BootstrapTableContainer);

      var _this = _possibleConstructorReturn(this, (BootstrapTableContainer.__proto__ || Object.getPrototypeOf(BootstrapTableContainer)).call(this, props));

      _this.DataContext = (0, _dataContext2.default)();

      if (props.columns.filter(function (col) {
        return col.sort;
      }).length > 0) {
        _this.SortContext = (0, _sortContext2.default)(_operators2.default, _this.isRemoteSort, _this.handleRemoteSortChange);
      }

      if (props.selectRow) {
        _this.SelectionContext = (0, _selectionContext2.default)(_operators2.default);
      }

      if (props.expandRow) {
        _this.RowExpandContext = (0, _rowExpandContext2.default)(_operators2.default);
      }

      if (props.cellEdit && props.cellEdit.createContext) {
        _this.CellEditContext = props.cellEdit.createContext(_utils2.default, _operators2.default, _this.isRemoteCellEdit, _this.handleRemoteCellChange);
      }

      if (props.filter) {
        _this.FilterContext = props.filter.createContext(_utils2.default, _this.isRemoteFiltering, _this.handleRemoteFilterChange);
      }

      if (props.pagination) {
        _this.PaginationContext = props.pagination.createContext(_this.isRemotePagination, _this.handleRemotePageChange);
      }

      if (props.search && props.search.searchContext) {
        _this.SearchContext = props.search.searchContext(_utils2.default, _this.isRemoteSearch, _this.handleRemoteSearchChange);
      }

      if (props.setDependencyModules) {
        props.setDependencyModules(_utils2.default);
      }
      return _this;
    }

    _createClass(BootstrapTableContainer, [{
      key: 'renderBase',
      value: function renderBase() {
        var _this2 = this;

        return function (rootProps, cellEditProps, filterProps, searchProps, sortProps, paginationProps, expandProps, selectionProps) {
          return _react2.default.createElement(Base, _extends({}, _this2.props, selectionProps, sortProps, cellEditProps, filterProps, searchProps, paginationProps, expandProps, {
            data: rootProps.getData(filterProps, searchProps, sortProps, paginationProps)
          }));
        };
      }
    }, {
      key: 'renderWithSelectionCtx',
      value: function renderWithSelectionCtx(base, baseProps) {
        var _this3 = this;

        return function (rootProps, cellEditProps, filterProps, searchProps, sortProps, paginationProps, expandProps) {
          return _react2.default.createElement(
            _this3.SelectionContext.Provider,
            _extends({}, baseProps, {
              selectRow: _this3.props.selectRow,
              data: rootProps.getData(filterProps, searchProps, sortProps, paginationProps)
            }),
            _react2.default.createElement(
              _this3.SelectionContext.Consumer,
              null,
              function (selectionProps) {
                return base(rootProps, cellEditProps, filterProps, searchProps, sortProps, paginationProps, expandProps, selectionProps);
              }
            )
          );
        };
      }
    }, {
      key: 'renderWithRowExpandCtx',
      value: function renderWithRowExpandCtx(base, baseProps) {
        var _this4 = this;

        return function (rootProps, cellEditProps, filterProps, searchProps, sortProps, paginationProps) {
          return _react2.default.createElement(
            _this4.RowExpandContext.Provider,
            _extends({}, baseProps, {
              expandRow: _this4.props.expandRow,
              data: rootProps.getData(filterProps, searchProps, sortProps, paginationProps)
            }),
            _react2.default.createElement(
              _this4.RowExpandContext.Consumer,
              null,
              function (expandProps) {
                return base(rootProps, cellEditProps, filterProps, searchProps, sortProps, paginationProps, expandProps);
              }
            )
          );
        };
      }
    }, {
      key: 'renderWithPaginationCtx',
      value: function renderWithPaginationCtx(base) {
        var _this5 = this;

        return function (rootProps, cellEditProps, filterProps, searchProps, sortProps) {
          return _react2.default.createElement(
            _this5.PaginationContext.Provider,
            {
              ref: function ref(n) {
                return _this5.paginationContext = n;
              },
              pagination: _this5.props.pagination,
              data: rootProps.getData(filterProps, searchProps, sortProps),
              bootstrap4: _this5.props.bootstrap4
            },
            _react2.default.createElement(
              _this5.PaginationContext.Consumer,
              null,
              function (paginationProps) {
                return base(rootProps, cellEditProps, filterProps, searchProps, sortProps, paginationProps);
              }
            )
          );
        };
      }
    }, {
      key: 'renderWithSortCtx',
      value: function renderWithSortCtx(base, baseProps) {
        var _this6 = this;

        return function (rootProps, cellEditProps, filterProps, searchProps) {
          return _react2.default.createElement(
            _this6.SortContext.Provider,
            _extends({}, baseProps, {
              ref: function ref(n) {
                return _this6.sortContext = n;
              },
              defaultSorted: _this6.props.defaultSorted,
              defaultSortDirection: _this6.props.defaultSortDirection,
              data: rootProps.getData(filterProps, searchProps)
            }),
            _react2.default.createElement(
              _this6.SortContext.Consumer,
              null,
              function (sortProps) {
                return base(rootProps, cellEditProps, filterProps, searchProps, sortProps);
              }
            )
          );
        };
      }
    }, {
      key: 'renderWithSearchCtx',
      value: function renderWithSearchCtx(base, baseProps) {
        var _this7 = this;

        return function (rootProps, cellEditProps, filterProps) {
          return _react2.default.createElement(
            _this7.SearchContext.Provider,
            _extends({}, baseProps, {
              ref: function ref(n) {
                return _this7.searchContext = n;
              },
              data: rootProps.getData(filterProps),
              searchText: _this7.props.search.searchText
            }),
            _react2.default.createElement(
              _this7.SearchContext.Consumer,
              null,
              function (searchProps) {
                return base(rootProps, cellEditProps, filterProps, searchProps);
              }
            )
          );
        };
      }
    }, {
      key: 'renderWithFilterCtx',
      value: function renderWithFilterCtx(base, baseProps) {
        var _this8 = this;

        return function (rootProps, cellEditProps) {
          return _react2.default.createElement(
            _this8.FilterContext.Provider,
            _extends({}, baseProps, {
              ref: function ref(n) {
                return _this8.filterContext = n;
              },
              data: rootProps.getData()
            }),
            _react2.default.createElement(
              _this8.FilterContext.Consumer,
              null,
              function (filterProps) {
                return base(rootProps, cellEditProps, filterProps);
              }
            )
          );
        };
      }
    }, {
      key: 'renderWithCellEditCtx',
      value: function renderWithCellEditCtx(base, baseProps) {
        var _this9 = this;

        return function (rootProps) {
          return _react2.default.createElement(
            _this9.CellEditContext.Provider,
            _extends({}, baseProps, {
              selectRow: _this9.props.selectRow,
              cellEdit: _this9.props.cellEdit,
              data: rootProps.getData()
            }),
            _react2.default.createElement(
              _this9.CellEditContext.Consumer,
              null,
              function (cellEditProps) {
                return base(rootProps, cellEditProps);
              }
            )
          );
        };
      }
    }, {
      key: 'render',
      value: function render() {
        var _props = this.props,
            keyField = _props.keyField,
            columns = _props.columns,
            bootstrap4 = _props.bootstrap4;

        var baseProps = { keyField: keyField, columns: columns };

        var base = this.renderBase();

        if (this.SelectionContext) {
          base = this.renderWithSelectionCtx(base, baseProps);
        }

        if (this.RowExpandContext) {
          base = this.renderWithRowExpandCtx(base, baseProps);
        }

        if (this.PaginationContext) {
          base = this.renderWithPaginationCtx(base, baseProps);
        }

        if (this.SortContext) {
          base = this.renderWithSortCtx(base, baseProps);
        }

        if (this.SearchContext) {
          base = this.renderWithSearchCtx(base, baseProps);
        }

        if (this.FilterContext) {
          base = this.renderWithFilterCtx(base, baseProps);
        }

        if (this.CellEditContext) {
          base = this.renderWithCellEditCtx(base, baseProps);
        }

        return _react2.default.createElement(
          _bootstrap.BootstrapContext.Provider,
          { value: { bootstrap4: bootstrap4 } },
          _react2.default.createElement(
            this.DataContext.Provider,
            _extends({}, baseProps, {
              data: this.props.data
            }),
            _react2.default.createElement(
              this.DataContext.Consumer,
              null,
              base
            )
          )
        );
      }
    }]);

    return BootstrapTableContainer;
  }((0, _remoteResolver3.default)(_react.Component));
};

exports.default = withContext;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = function () {
  var DataContext = _react2.default.createContext();

  var DataProvider = function (_Component) {
    _inherits(DataProvider, _Component);

    function DataProvider() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, DataProvider);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = DataProvider.__proto__ || Object.getPrototypeOf(DataProvider)).call.apply(_ref, [this].concat(args))), _this), _this.state = { data: _this.props.data }, _this.getData = function (filterProps, searchProps, sortProps, paginationProps) {
        if (paginationProps) return paginationProps.data;else if (sortProps) return sortProps.data;else if (searchProps) return searchProps.data;else if (filterProps) return filterProps.data;
        return _this.props.data;
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(DataProvider, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        this.setState(function () {
          return { data: nextProps.data };
        });
      }
    }, {
      key: 'render',
      value: function render() {
        return _react2.default.createElement(
          DataContext.Provider,
          {
            value: {
              data: this.state.data,
              getData: this.getData
            }
          },
          this.props.children
        );
      }
    }]);

    return DataProvider;
  }(_react.Component);

  DataProvider.propTypes = {
    data: _propTypes2.default.array.isRequired,
    children: _propTypes2.default.node.isRequired
  };

  return {
    Provider: DataProvider,
    Consumer: DataContext.Consumer
  };
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */


exports.default = function (dataOperator, isRemoteSort, handleSortChange) {
  var SortContext = _react2.default.createContext();

  var SortProvider = function (_React$Component) {
    _inherits(SortProvider, _React$Component);

    function SortProvider(props) {
      _classCallCheck(this, SortProvider);

      var _this = _possibleConstructorReturn(this, (SortProvider.__proto__ || Object.getPrototypeOf(SortProvider)).call(this, props));

      _initialiseProps.call(_this);

      var sortOrder = void 0;
      var sortColumn = void 0;
      var columns = props.columns,
          defaultSorted = props.defaultSorted,
          defaultSortDirection = props.defaultSortDirection;


      if (defaultSorted && defaultSorted.length > 0) {
        var sortField = defaultSorted[0].dataField;
        sortOrder = defaultSorted[0].order || defaultSortDirection;
        var sortColumns = columns.filter(function (col) {
          return col.dataField === sortField;
        });
        if (sortColumns.length > 0) {
          sortColumn = sortColumns[0];

          if (sortColumn.onSort) {
            sortColumn.onSort(sortField, sortOrder);
          }
        }
      }
      _this.state = { sortOrder: sortOrder, sortColumn: sortColumn };
      return _this;
    }

    _createClass(SortProvider, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _state = this.state,
            sortOrder = _state.sortOrder,
            sortColumn = _state.sortColumn;

        if (isRemoteSort() && sortOrder && sortColumn) {
          handleSortChange(sortColumn.dataField, sortOrder);
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var data = this.props.data;
        var _state2 = this.state,
            sortOrder = _state2.sortOrder,
            sortColumn = _state2.sortColumn;

        if (!isRemoteSort() && sortColumn) {
          data = dataOperator.sort(data, sortOrder, sortColumn);
        }

        return _react2.default.createElement(
          SortContext.Provider,
          {
            value: {
              data: data,
              sortOrder: sortOrder,
              onSort: this.handleSort,
              sortField: sortColumn ? sortColumn.dataField : null
            }
          },
          this.props.children
        );
      }
    }]);

    return SortProvider;
  }(_react2.default.Component);

  SortProvider.propTypes = {
    data: _propTypes2.default.array.isRequired,
    columns: _propTypes2.default.array.isRequired,
    children: _propTypes2.default.node.isRequired,
    defaultSorted: _propTypes2.default.arrayOf(_propTypes2.default.shape({
      dataField: _propTypes2.default.string.isRequired,
      order: _propTypes2.default.oneOf([_const2.default.SORT_DESC, _const2.default.SORT_ASC]).isRequired
    })),
    defaultSortDirection: _propTypes2.default.oneOf([_const2.default.SORT_DESC, _const2.default.SORT_ASC])
  };

  var _initialiseProps = function _initialiseProps() {
    var _this2 = this;

    this.handleSort = function (column) {
      var sortOrder = dataOperator.nextOrder(column, _this2.state, _this2.props.defaultSortDirection);

      if (column.onSort) {
        column.onSort(column.dataField, sortOrder);
      }

      if (isRemoteSort()) {
        handleSortChange(column.dataField, sortOrder);
      }
      _this2.setState(function () {
        return {
          sortOrder: sortOrder,
          sortColumn: column
        };
      });
    };
  };

  return {
    Provider: SortProvider,
    Consumer: SortContext.Consumer
  };
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */


exports.default = function (dataOperator) {
  var SelectionContext = _react2.default.createContext();

  var SelectionProvider = function (_React$Component) {
    _inherits(SelectionProvider, _React$Component);

    function SelectionProvider() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, SelectionProvider);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = SelectionProvider.__proto__ || Object.getPrototypeOf(SelectionProvider)).call.apply(_ref, [this].concat(args))), _this), _this.state = { selected: _this.props.selectRow && _this.props.selectRow.selected || [] }, _this.handleRowSelect = function (rowKey, checked, rowIndex, e) {
        var _this$props = _this.props,
            data = _this$props.data,
            keyField = _this$props.keyField,
            _this$props$selectRow = _this$props.selectRow,
            mode = _this$props$selectRow.mode,
            onSelect = _this$props$selectRow.onSelect;
        var ROW_SELECT_SINGLE = _const2.default.ROW_SELECT_SINGLE;


        var currSelected = [].concat(_toConsumableArray(_this.state.selected));

        if (mode === ROW_SELECT_SINGLE) {
          // when select mode is radio
          currSelected = [rowKey];
        } else if (checked) {
          // when select mode is checkbox
          currSelected.push(rowKey);
        } else {
          currSelected = currSelected.filter(function (value) {
            return value !== rowKey;
          });
        }

        if (onSelect) {
          var row = dataOperator.getRowByRowId(data, keyField, rowKey);
          onSelect(row, checked, rowIndex, e);
        }

        _this.setState(function () {
          return { selected: currSelected };
        });
      }, _this.handleAllRowsSelect = function (e, isUnSelect) {
        var _this$props2 = _this.props,
            data = _this$props2.data,
            keyField = _this$props2.keyField,
            _this$props2$selectRo = _this$props2.selectRow,
            onSelectAll = _this$props2$selectRo.onSelectAll,
            nonSelectable = _this$props2$selectRo.nonSelectable;
        var selected = _this.state.selected;


        var currSelected = void 0;

        if (!isUnSelect) {
          currSelected = selected.concat(dataOperator.selectableKeys(data, keyField, nonSelectable));
        } else {
          currSelected = selected.filter(function (s) {
            return typeof data.find(function (d) {
              return d[keyField] === s;
            }) === 'undefined';
          });
        }

        if (onSelectAll) {
          onSelectAll(!isUnSelect, dataOperator.getSelectedRows(data, keyField, currSelected), e);
        }

        _this.setState(function () {
          return { selected: currSelected };
        });
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(SelectionProvider, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var _this2 = this;

        if (nextProps.selectRow) {
          this.setState(function () {
            return {
              selected: nextProps.selectRow.selected || _this2.state.selected
            };
          });
        }
      }
    }, {
      key: 'render',
      value: function render() {
        return _react2.default.createElement(
          SelectionContext.Provider,
          {
            value: {
              selected: this.state.selected,
              onRowSelect: this.handleRowSelect,
              onAllRowsSelect: this.handleAllRowsSelect
            }
          },
          this.props.children
        );
      }
    }]);

    return SelectionProvider;
  }(_react2.default.Component);

  SelectionProvider.propTypes = {
    children: _propTypes2.default.node.isRequired,
    data: _propTypes2.default.array.isRequired,
    keyField: _propTypes2.default.string.isRequired
  };

  return {
    Provider: SelectionProvider,
    Consumer: SelectionContext.Consumer
  };
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */


exports.default = function (dataOperator) {
  var RowExpandContext = _react2.default.createContext();

  var RowExpandProvider = function (_React$Component) {
    _inherits(RowExpandProvider, _React$Component);

    function RowExpandProvider() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, RowExpandProvider);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = RowExpandProvider.__proto__ || Object.getPrototypeOf(RowExpandProvider)).call.apply(_ref, [this].concat(args))), _this), _this.state = { expanded: _this.props.expandRow.expanded || [] }, _this.handleRowExpand = function (rowKey, expanded, rowIndex, e) {
        var _this$props = _this.props,
            data = _this$props.data,
            keyField = _this$props.keyField,
            onExpand = _this$props.expandRow.onExpand;


        var currExpanded = [].concat(_toConsumableArray(_this.state.expanded));

        if (expanded) {
          currExpanded.push(rowKey);
        } else {
          currExpanded = currExpanded.filter(function (value) {
            return value !== rowKey;
          });
        }

        if (onExpand) {
          var row = dataOperator.getRowByRowId(data, keyField, rowKey);
          onExpand(row, expanded, rowIndex, e);
        }
        _this.setState(function () {
          return { expanded: currExpanded };
        });
      }, _this.handleAllRowExpand = function (e, expandAll) {
        var _this$props2 = _this.props,
            data = _this$props2.data,
            keyField = _this$props2.keyField,
            _this$props2$expandRo = _this$props2.expandRow,
            onExpandAll = _this$props2$expandRo.onExpandAll,
            nonExpandable = _this$props2$expandRo.nonExpandable;
        var expanded = _this.state.expanded;


        var currExpanded = void 0;

        if (expandAll) {
          currExpanded = expanded.concat(dataOperator.expandableKeys(data, keyField, nonExpandable));
        } else {
          currExpanded = expanded.filter(function (s) {
            return typeof data.find(function (d) {
              return d[keyField] === s;
            }) === 'undefined';
          });
        }

        if (onExpandAll) {
          onExpandAll(expandAll, dataOperator.getExpandedRows(data, keyField, currExpanded), e);
        }

        _this.setState(function () {
          return { expanded: currExpanded };
        });
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(RowExpandProvider, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var _this2 = this;

        if (nextProps.expandRow) {
          this.setState(function () {
            return {
              expanded: nextProps.expandRow.expanded || _this2.state.expanded
            };
          });
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _props = this.props,
            data = _props.data,
            keyField = _props.keyField;

        return _react2.default.createElement(
          RowExpandContext.Provider,
          {
            value: {
              isAnyExpands: dataOperator.isAnyExpands(data, keyField, this.state.expanded),
              expanded: this.state.expanded,
              onRowExpand: this.handleRowExpand,
              onAllRowExpand: this.handleAllRowExpand
            }
          },
          this.props.children
        );
      }
    }]);

    return RowExpandProvider;
  }(_react2.default.Component);

  RowExpandProvider.propTypes = {
    children: _propTypes2.default.node.isRequired,
    data: _propTypes2.default.array.isRequired,
    keyField: _propTypes2.default.string.isRequired
  };

  return {
    Provider: RowExpandProvider,
    Consumer: RowExpandContext.Consumer
  };
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = function (ExtendBase) {
  return function (_ExtendBase) {
    _inherits(RemoteResolver, _ExtendBase);

    function RemoteResolver() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, RemoteResolver);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = RemoteResolver.__proto__ || Object.getPrototypeOf(RemoteResolver)).call.apply(_ref, [this].concat(args))), _this), _this.getNewestState = function () {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var sortOrder = void 0;
        var sortField = void 0;
        var page = void 0;
        var sizePerPage = void 0;
        var searchText = void 0;
        var filters = {};

        if (_this.sortContext) {
          sortOrder = _this.sortContext.state.sortOrder;
          sortField = _this.sortContext.state.sortColumn ? _this.sortContext.state.sortColumn.dataField : null;
        }

        if (_this.filterContext) {
          filters = _this.filterContext.currFilters;
        }

        if (_this.paginationContext) {
          page = _this.paginationContext.currPage;
          sizePerPage = _this.paginationContext.currSizePerPage;
        }

        if (_this.searchContext) {
          searchText = _this.props.search.searchText;
        }

        return _extends({
          sortOrder: sortOrder,
          sortField: sortField,
          filters: filters,
          page: page,
          sizePerPage: sizePerPage,
          searchText: searchText
        }, state, {
          data: _this.props.data
        });
      }, _this.isRemoteSearch = function () {
        var remote = _this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.search || _this.isRemotePagination();
      }, _this.isRemotePagination = function () {
        var remote = _this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.pagination;
      }, _this.isRemoteFiltering = function () {
        var remote = _this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.filter || _this.isRemotePagination();
      }, _this.isRemoteSort = function () {
        var remote = _this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.sort || _this.isRemotePagination();
      }, _this.isRemoteCellEdit = function () {
        var remote = _this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.cellEdit;
      }, _this.handleRemotePageChange = function (page, sizePerPage) {
        _this.props.onTableChange('pagination', _this.getNewestState({ page: page, sizePerPage: sizePerPage }));
      }, _this.handleRemoteFilterChange = function (filters) {
        var newState = { filters: filters };
        if (_this.isRemotePagination()) {
          var options = _this.props.pagination.options || {};
          newState.page = _utils2.default.isDefined(options.pageStartIndex) ? options.pageStartIndex : 1;
        }
        _this.props.onTableChange('filter', _this.getNewestState(newState));
      }, _this.handleRemoteSortChange = function (sortField, sortOrder) {
        _this.props.onTableChange('sort', _this.getNewestState({ sortField: sortField, sortOrder: sortOrder }));
      }, _this.handleRemoteCellChange = function (rowId, dataField, newValue) {
        var cellEdit = { rowId: rowId, dataField: dataField, newValue: newValue };
        _this.props.onTableChange('cellEdit', _this.getNewestState({ cellEdit: cellEdit }));
      }, _this.handleRemoteSearchChange = function (searchText) {
        _this.props.onTableChange('search', _this.getNewestState({ searchText: searchText }));
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    return RemoteResolver;
  }(ExtendBase);
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _rows = __webpack_require__(6);

var rows = _interopRequireWildcard(_rows);

var _selection = __webpack_require__(7);

var selection = _interopRequireWildcard(_selection);

var _expand = __webpack_require__(39);

var expand = _interopRequireWildcard(_expand);

var _mutate = __webpack_require__(40);

var mutate = _interopRequireWildcard(_mutate);

var _sort = __webpack_require__(41);

var sort = _interopRequireWildcard(_sort);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = _extends({}, rows, selection, expand, mutate, sort);

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getExpandedRows = exports.expandableKeys = exports.isAnyExpands = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _rows = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isAnyExpands = exports.isAnyExpands = function isAnyExpands(data, keyField) {
  var expanded = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  var _loop = function _loop(i) {
    var rowKey = _utils2.default.get(data[i], keyField);
    if (typeof expanded.find(function (x) {
      return x === rowKey;
    }) !== 'undefined') {
      return {
        v: true
      };
    }
  };

  for (var i = 0; i < data.length; i += 1) {
    var _ret = _loop(i);

    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
  }
  return false;
};

var expandableKeys = exports.expandableKeys = function expandableKeys(data, keyField) {
  var skips = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (skips.length === 0) {
    return data.map(function (row) {
      return _utils2.default.get(row, keyField);
    });
  }
  return data.filter(function (row) {
    return !skips.includes(_utils2.default.get(row, keyField));
  }).map(function (row) {
    return _utils2.default.get(row, keyField);
  });
};

var getExpandedRows = exports.getExpandedRows = function getExpandedRows(data, keyField, expanded) {
  return expanded.map(function (k) {
    return (0, _rows.getRowByRowId)(data, keyField, k);
  });
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.editCell = undefined;

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _rows = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var editCell = exports.editCell = function editCell(data, keyField, rowId, dataField, newValue) {
  var row = (0, _rows.getRowByRowId)(data, keyField, rowId);
  if (row) _utils2.default.set(row, dataField, newValue);
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nextOrder = exports.sort = undefined;

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /* eslint no-nested-ternary: 0 */
/* eslint no-lonely-if: 0 */
/* eslint no-underscore-dangle: 0 */


function comparator(a, b) {
  var result = void 0;
  if (typeof b === 'string') {
    result = b.localeCompare(a);
  } else {
    result = a > b ? -1 : a < b ? 1 : 0;
  }
  return result;
}

var sort = exports.sort = function sort(data, sortOrder, _ref) {
  var dataField = _ref.dataField,
      sortFunc = _ref.sortFunc;

  var _data = [].concat(_toConsumableArray(data));
  _data.sort(function (a, b) {
    var result = void 0;
    var valueA = _utils2.default.get(a, dataField);
    var valueB = _utils2.default.get(b, dataField);
    valueA = _utils2.default.isDefined(valueA) ? valueA : '';
    valueB = _utils2.default.isDefined(valueB) ? valueB : '';

    if (sortFunc) {
      result = sortFunc(valueA, valueB, sortOrder, dataField);
    } else {
      if (sortOrder === _const2.default.SORT_DESC) {
        result = comparator(valueA, valueB);
      } else {
        result = comparator(valueB, valueA);
      }
    }
    return result;
  });
  return _data;
};

var nextOrder = exports.nextOrder = function nextOrder(currentSortColumn, _ref2) {
  var sortOrder = _ref2.sortOrder,
      sortColumn = _ref2.sortColumn;
  var defaultOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _const2.default.SORT_DESC;

  if (!sortColumn || currentSortColumn.dataField !== sortColumn.dataField) return defaultOrder;
  return sortOrder === _const2.default.SORT_DESC ? _const2.default.SORT_ASC : _const2.default.SORT_DESC;
};

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA2OWRmOGQ2NzNiY2Q3ZDY3MDBiOSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RcIixcImNvbW1vbmpzMlwiOlwicmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiYW1kXCI6XCJyZWFjdFwifSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb250ZXh0cy9ib290c3RyYXAuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zdG9yZS9yb3dzLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3N0b3JlL3NlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL2luZGV4LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2Jvb3RzdHJhcC10YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvaGVhZGVyLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2hlYWRlci1jZWxsLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3NvcnQvc3ltYm9sLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3NvcnQvY2FyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LXNlbGVjdGlvbi9zZWxlY3Rpb24taGVhZGVyLWNlbGwuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LWV4cGFuZC9leHBhbmQtaGVhZGVyLWNlbGwuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvY2FwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9ib2R5LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jZWxsLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1zZWxlY3Rpb24vc2VsZWN0aW9uLWNlbGwuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LWV4cGFuZC9leHBhbmQtY2VsbC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9yb3ctZXZlbnQtZGVsZWdhdGVyLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1leHBhbmQvZXhwYW5kLXJvdy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9yb3ctc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9jb2x1bW4tcmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcHJvcHMtcmVzb2x2ZXIvZXhwYW5kLXJvdy1yZXNvbHZlci5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb250ZXh0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb250ZXh0cy9kYXRhLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvY29udGV4dHMvc29ydC1jb250ZXh0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2NvbnRleHRzL3NlbGVjdGlvbi1jb250ZXh0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2NvbnRleHRzL3Jvdy1leHBhbmQtY29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9yZW1vdGUtcmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc3RvcmUvb3BlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3N0b3JlL2V4cGFuZC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zdG9yZS9tdXRhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc3RvcmUvc29ydC5qcyJdLCJuYW1lcyI6WyJTT1JUX0FTQyIsIlNPUlRfREVTQyIsIlJPV19TRUxFQ1RfU0lOR0xFIiwiUk9XX1NFTEVDVF9NVUxUSVBMRSIsIlJPV19TRUxFQ1RfRElTQUJMRUQiLCJDSEVDS0JPWF9TVEFUVVNfQ0hFQ0tFRCIsIkNIRUNLQk9YX1NUQVRVU19JTkRFVEVSTUlOQVRFIiwiQ0hFQ0tCT1hfU1RBVFVTX1VOQ0hFQ0tFRCIsInNwbGl0TmVzdGVkIiwic3RyIiwiam9pbiIsInJlcGxhY2UiLCJzcGxpdCIsImdldCIsInRhcmdldCIsImZpZWxkIiwicGF0aEFycmF5IiwicmVzdWx0IiwicmVkdWNlIiwiY3VyciIsInBhdGgiLCJlIiwic2V0IiwidmFsdWUiLCJzYWZlIiwibGV2ZWwiLCJhIiwiYiIsIkVycm9yIiwibGVuZ3RoIiwiaXNGdW5jdGlvbiIsIm9iaiIsImlzT2JqZWN0IiwidHlwZSIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwiaXNFbXB0eU9iamVjdCIsImhhc093blByb3BlcnR5IiwicHJvdG90eXBlIiwia2V5cyIsImkiLCJjYWxsIiwiaXNEZWZpbmVkIiwic2xlZXAiLCJmbiIsIm1zIiwic2V0VGltZW91dCIsImRlYm91bmNlIiwiZnVuYyIsIndhaXQiLCJpbW1lZGlhdGUiLCJ0aW1lb3V0IiwibGF0ZXIiLCJhcHBseSIsImNhbGxOb3ciLCJjbGVhclRpbWVvdXQiLCJhcHB5IiwiQm9vdHN0cmFwQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJib290c3RyYXA0IiwibWF0Y2hSb3ciLCJrZXlGaWVsZCIsImlkIiwicm93IiwiZ2V0Um93QnlSb3dJZCIsImRhdGEiLCJmaW5kIiwiZ2V0U2VsZWN0aW9uU3VtbWFyeSIsInNlbGVjdGVkIiwiYWxsUm93c1NlbGVjdGVkIiwiYWxsUm93c05vdFNlbGVjdGVkIiwicm93S2V5cyIsIm1hcCIsImQiLCJ4Iiwic2VsZWN0YWJsZUtleXMiLCJza2lwcyIsImZpbHRlciIsImluY2x1ZGVzIiwidW5TZWxlY3RhYmxlS2V5cyIsImdldFNlbGVjdGVkUm93cyIsImsiLCJCb290c3RyYXBUYWJsZSIsInByb3BzIiwidmFsaWRhdGVQcm9wcyIsImxvYWRpbmciLCJvdmVybGF5IiwiTG9hZGluZ092ZXJsYXkiLCJyZW5kZXJUYWJsZSIsImNvbHVtbnMiLCJjbGFzc2VzIiwic3RyaXBlZCIsImhvdmVyIiwiYm9yZGVyZWQiLCJjb25kZW5zZWQiLCJub0RhdGFJbmRpY2F0aW9uIiwiY2FwdGlvbiIsInJvd1N0eWxlIiwicm93Q2xhc3NlcyIsIndyYXBwZXJDbGFzc2VzIiwicm93RXZlbnRzIiwidGFibGVXcmFwcGVyQ2xhc3MiLCJ0YWJsZUNsYXNzIiwiY2VsbFNlbGVjdGlvbkluZm8iLCJyZXNvbHZlU2VsZWN0Um93UHJvcHMiLCJvblJvd1NlbGVjdCIsImhlYWRlckNlbGxTZWxlY3Rpb25JbmZvIiwicmVzb2x2ZVNlbGVjdFJvd1Byb3BzRm9ySGVhZGVyIiwib25BbGxSb3dzU2VsZWN0IiwidGFibGVDYXB0aW9uIiwiZXhwYW5kUm93IiwicmVzb2x2ZUV4cGFuZFJvd1Byb3BzIiwiaGVhZGVyQ2xhc3NlcyIsInNvcnRGaWVsZCIsInNvcnRPcmRlciIsIm9uU29ydCIsIm9uRmlsdGVyIiwib25FeHRlcm5hbEZpbHRlciIsImlzRW1wdHkiLCJ2aXNpYmxlQ29sdW1uU2l6ZSIsImNlbGxFZGl0IiwicHJvcFR5cGVzIiwic3RyaW5nIiwiaXNSZXF1aXJlZCIsImFycmF5IiwiYm9vbCIsInJlbW90ZSIsIm9uZU9mVHlwZSIsInNoYXBlIiwicGFnaW5hdGlvbiIsIm5vZGUiLCJvYmplY3QiLCJzZWxlY3RSb3ciLCJtb2RlIiwib25lT2YiLCJjbGlja1RvU2VsZWN0IiwiY2xpY2tUb0VkaXQiLCJvblNlbGVjdCIsIm9uU2VsZWN0QWxsIiwic3R5bGUiLCJub25TZWxlY3RhYmxlIiwiYmdDb2xvciIsImhpZGVTZWxlY3RDb2x1bW4iLCJzZWxlY3Rpb25SZW5kZXJlciIsInNlbGVjdGlvbkhlYWRlclJlbmRlcmVyIiwicmVuZGVyZXIiLCJleHBhbmRlZCIsIm9uRXhwYW5kIiwib25FeHBhbmRBbGwiLCJub25FeHBhbmRhYmxlIiwic2hvd0V4cGFuZENvbHVtbiIsImV4cGFuZENvbHVtblJlbmRlcmVyIiwiZXhwYW5kSGVhZGVyQ29sdW1uUmVuZGVyZXIiLCJvblJvd0V4cGFuZCIsIm9uQWxsUm93RXhwYW5kIiwiaXNBbnlFeHBhbmRzIiwiZGVmYXVsdFNvcnRlZCIsImFycmF5T2YiLCJkYXRhRmllbGQiLCJvcmRlciIsImRlZmF1bHRTb3J0RGlyZWN0aW9uIiwib25UYWJsZUNoYW5nZSIsInNlYXJjaCIsInNlYXJjaFRleHQiLCJzZWFyY2hDb250ZXh0Iiwic2V0RGVwZW5kZW5jeU1vZHVsZXMiLCJkZWZhdWx0UHJvcHMiLCJIZWFkZXIiLCJjbGFzc05hbWUiLCJjb2x1bW4iLCJoaWRkZW4iLCJjdXJyU29ydCIsImlzTGFzdFNvcnRpbmciLCJIZWFkZXJDZWxsIiwiaW5kZXgiLCJzb3J0aW5nIiwidGV4dCIsInNvcnQiLCJmaWx0ZXJSZW5kZXJlciIsImhlYWRlclRpdGxlIiwiaGVhZGVyQWxpZ24iLCJoZWFkZXJGb3JtYXR0ZXIiLCJoZWFkZXJFdmVudHMiLCJoZWFkZXJTdHlsZSIsImhlYWRlckF0dHJzIiwiaGVhZGVyU29ydGluZ0NsYXNzZXMiLCJoZWFkZXJTb3J0aW5nU3R5bGUiLCJjZWxsQXR0cnMiLCJzb3J0U3ltYm9sIiwiZmlsdGVyRWxtIiwiY2VsbFN0eWxlIiwiY2VsbENsYXNzZXMiLCJ0aXRsZSIsInRleHRBbGlnbiIsImN1c3RvbUNsaWNrIiwib25DbGljayIsIm9uQ3VzdG9tRmlsdGVyIiwiY2hpbGRyZW4iLCJzb3J0RWxlbWVudCIsImZpbHRlckVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZm9ybWF0dGVyIiwiZm9ybWF0RXh0cmFEYXRhIiwiYW55IiwiZXZlbnRzIiwiYWxpZ24iLCJhdHRycyIsInNvcnRGdW5jIiwiZWRpdG9yIiwiZWRpdGFibGUiLCJlZGl0Q2VsbFN0eWxlIiwiZWRpdENlbGxDbGFzc2VzIiwiZWRpdG9yU3R5bGUiLCJlZGl0b3JDbGFzc2VzIiwiZWRpdG9yUmVuZGVyZXIiLCJ2YWxpZGF0b3IiLCJmaWx0ZXJWYWx1ZSIsIm51bWJlciIsIlNvcnRTeW1ib2wiLCJTb3J0Q2FyZXQiLCJvcmRlckNsYXNzIiwiZHJvcHVwIiwiQ2hlY2tCb3giLCJjaGVja2VkIiwiaW5kZXRlcm1pbmF0ZSIsImlucHV0IiwiU2VsZWN0aW9uSGVhZGVyQ2VsbCIsImhhbmRsZUNoZWNrQm94Q2xpY2siLCJiaW5kIiwibmV4dFByb3BzIiwiY2hlY2tlZFN0YXR1cyIsImlzVW5TZWxlY3QiLCJjb250ZW50IiwiYW55RXhwYW5kcyIsIkNhcHRpb24iLCJCb2R5Iiwic2VsZWN0ZWRSb3dLZXlzIiwiaW5kaWNhdGlvbiIsIm5vbkVkaXRhYmxlUm93cyIsImtleSIsImluZGV4T2YiLCJzZWxlY3RlZFN0eWxlIiwic2VsZWN0ZWRDbGFzc2VzIiwiYmFja2dyb3VuZENvbG9yIiwic2VsZWN0YWJsZSIsImV4cGFuZGFibGUiLCJwdXNoIiwiUm93Iiwicm93SW5kZXgiLCJlZGl0YWJsZVJvdyIsIm9uU3RhcnQiLCJFZGl0aW5nQ2VsbCIsImVkaXRpbmdSb3dJZHgiLCJyaWR4IiwiZWRpdGluZ0NvbElkeCIsImNpZHgiLCJDTElDS19UT19DRUxMX0VESVQiLCJEQkNMSUNLX1RPX0NFTExfRURJVCIsInJlc3QiLCJ0ckF0dHJzIiwiZGVsZWdhdGUiLCJlZGl0Q2VsbHN0eWxlIiwiZWRpdENlbGxjbGFzc2VzIiwiQ2VsbCIsImhhbmRsZUVkaXRpbmdDZWxsIiwiY29sdW1uSW5kZXgiLCJkYmNsaWNrVG9FZGl0IiwiY3VzdG9tRGJDbGljayIsIm9uRG91YmxlQ2xpY2siLCJjZWxsVGl0bGUiLCJTZWxlY3Rpb25DZWxsIiwiaGFuZGxlQ2xpY2siLCJpbnB1dFR5cGUiLCJyb3dLZXkiLCJkaXNhYmxlZCIsIkV4cGFuZENlbGwiLCJjbGlja051bSIsImNyZWF0ZURlZmF1bHRFdmVudEhhbmRsZXIiLCJjcmVhdGVDbGlja0V2ZW50SGFuZGxlciIsImNiIiwiREVMQVlfRk9SX0RCQ0xJQ0siLCJjbGlja0ZuIiwibmV3QXR0cnMiLCJmb3JFYWNoIiwiYXR0ciIsIkV4dGVuZEJhc2UiLCJFeHBhbmRSb3ciLCJSb3dTZWN0aW9uIiwiY29sU3BhbiIsIm9wdGlvbnMiLCJpbmNsdWRlU2VsZWN0Q29sdW1uIiwiY29sdW1uTGVuIiwiYyIsIndpdGhDb250ZXh0IiwiRGF0YUNvbnRleHQiLCJjb2wiLCJTb3J0Q29udGV4dCIsImlzUmVtb3RlU29ydCIsImhhbmRsZVJlbW90ZVNvcnRDaGFuZ2UiLCJTZWxlY3Rpb25Db250ZXh0IiwiUm93RXhwYW5kQ29udGV4dCIsIkNlbGxFZGl0Q29udGV4dCIsImlzUmVtb3RlQ2VsbEVkaXQiLCJoYW5kbGVSZW1vdGVDZWxsQ2hhbmdlIiwiRmlsdGVyQ29udGV4dCIsImlzUmVtb3RlRmlsdGVyaW5nIiwiaGFuZGxlUmVtb3RlRmlsdGVyQ2hhbmdlIiwiUGFnaW5hdGlvbkNvbnRleHQiLCJpc1JlbW90ZVBhZ2luYXRpb24iLCJoYW5kbGVSZW1vdGVQYWdlQ2hhbmdlIiwiU2VhcmNoQ29udGV4dCIsImlzUmVtb3RlU2VhcmNoIiwiaGFuZGxlUmVtb3RlU2VhcmNoQ2hhbmdlIiwicm9vdFByb3BzIiwiY2VsbEVkaXRQcm9wcyIsImZpbHRlclByb3BzIiwic2VhcmNoUHJvcHMiLCJzb3J0UHJvcHMiLCJwYWdpbmF0aW9uUHJvcHMiLCJleHBhbmRQcm9wcyIsInNlbGVjdGlvblByb3BzIiwiZ2V0RGF0YSIsImJhc2UiLCJiYXNlUHJvcHMiLCJwYWdpbmF0aW9uQ29udGV4dCIsIm4iLCJzb3J0Q29udGV4dCIsImZpbHRlckNvbnRleHQiLCJyZW5kZXJCYXNlIiwicmVuZGVyV2l0aFNlbGVjdGlvbkN0eCIsInJlbmRlcldpdGhSb3dFeHBhbmRDdHgiLCJyZW5kZXJXaXRoUGFnaW5hdGlvbkN0eCIsInJlbmRlcldpdGhTb3J0Q3R4IiwicmVuZGVyV2l0aFNlYXJjaEN0eCIsInJlbmRlcldpdGhGaWx0ZXJDdHgiLCJyZW5kZXJXaXRoQ2VsbEVkaXRDdHgiLCJEYXRhUHJvdmlkZXIiLCJzdGF0ZSIsInNldFN0YXRlIiwiUHJvdmlkZXIiLCJDb25zdW1lciIsImRhdGFPcGVyYXRvciIsImhhbmRsZVNvcnRDaGFuZ2UiLCJTb3J0UHJvdmlkZXIiLCJzb3J0Q29sdW1uIiwic29ydENvbHVtbnMiLCJoYW5kbGVTb3J0IiwiQ29tcG9uZW50IiwibmV4dE9yZGVyIiwiU2VsZWN0aW9uUHJvdmlkZXIiLCJoYW5kbGVSb3dTZWxlY3QiLCJjdXJyU2VsZWN0ZWQiLCJoYW5kbGVBbGxSb3dzU2VsZWN0IiwiY29uY2F0IiwicyIsIlJvd0V4cGFuZFByb3ZpZGVyIiwiaGFuZGxlUm93RXhwYW5kIiwiY3VyckV4cGFuZGVkIiwiaGFuZGxlQWxsUm93RXhwYW5kIiwiZXhwYW5kQWxsIiwiZXhwYW5kYWJsZUtleXMiLCJnZXRFeHBhbmRlZFJvd3MiLCJnZXROZXdlc3RTdGF0ZSIsInBhZ2UiLCJzaXplUGVyUGFnZSIsImZpbHRlcnMiLCJjdXJyRmlsdGVycyIsImN1cnJQYWdlIiwiY3VyclNpemVQZXJQYWdlIiwibmV3U3RhdGUiLCJwYWdlU3RhcnRJbmRleCIsInJvd0lkIiwibmV3VmFsdWUiLCJyb3dzIiwic2VsZWN0aW9uIiwiZXhwYW5kIiwibXV0YXRlIiwiZWRpdENlbGwiLCJjb21wYXJhdG9yIiwibG9jYWxlQ29tcGFyZSIsIl9kYXRhIiwidmFsdWVBIiwidmFsdWVCIiwiY3VycmVudFNvcnRDb2x1bW4iLCJkZWZhdWx0T3JkZXIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM3REEsK0M7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O2tCQzdCZTtBQUNiQSxZQUFVLEtBREc7QUFFYkMsYUFBVyxNQUZFO0FBR2JDLHFCQUFtQixPQUhOO0FBSWJDLHVCQUFxQixVQUpSO0FBS2JDLHVCQUFxQixxQkFMUjtBQU1iQywyQkFBeUIsU0FOWjtBQU9iQyxpQ0FBK0IsZUFQbEI7QUFRYkMsNkJBQTJCO0FBUmQsQzs7Ozs7Ozs7Ozs7Ozs7O0FDQWY7QUFDQTtBQUNBOztBQUVBLFNBQVNDLFdBQVQsQ0FBcUJDLEdB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QUFXSSxNQUFYLEVBQW1CRCxNQUFuQixDQUFUO0FBQ0Q7QUFDRjtBQUNELFdBQU81VyxNQUFQO0FBQ0QsR0FqQkQ7QUFrQkEsU0FBTzJXLEtBQVA7QUFDRCxDQXJCTTs7QUF1QkEsSUFBTWhDLGdDQUFZLFNBQVpBLFNBQVksQ0FDdkJtQyxpQkFEdUIsU0FJcEI7QUFBQSxNQUZEN1EsU0FFQyxTQUZEQSxTQUVDO0FBQUEsTUFGVXNPLFVBRVYsU0FGVUEsVUFFVjtBQUFBLE1BREh3QyxZQUNHLHVFQURZLGdCQUFNL1gsU0FDbEI7O0FBQ0gsTUFBSSxDQUFDdVYsVUFBRCxJQUFldUMsa0JBQWtCak8sU0FBbEIsS0FBZ0MwTCxXQUFXMUwsU0FBOUQsRUFBeUUsT0FBT2tPLFlBQVA7QUFDekUsU0FBTzlRLGNBQWMsZ0JBQU1qSCxTQUFwQixHQUFnQyxnQkFBTUQsUUFBdEMsR0FBaUQsZ0JBQU1DLFNBQTlEO0FBQ0QsQ0FQTSxDIiwiZmlsZSI6InJlYWN0LWJvb3RzdHJhcC10YWJsZTIvZGlzdC9yZWFjdC1ib290c3RyYXAtdGFibGUtbmV4dC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInJlYWN0XCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlJlYWN0Qm9vdHN0cmFwVGFibGUyXCJdID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlJlYWN0Qm9vdHN0cmFwVGFibGUyXCJdID0gZmFjdG9yeShyb290W1wiUmVhY3RcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX18pIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gOCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNjlkZjhkNjczYmNkN2Q2NzAwYjkiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIHtcInJvb3RcIjpcIlJlYWN0XCIsXCJjb21tb25qczJcIjpcInJlYWN0XCIsXCJjb21tb25qc1wiOlwicmVhY3RcIixcImFtZFwiOlwicmVhY3RcIn1cbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImV4cG9ydCBkZWZhdWx0IHtcbiAgU09SVF9BU0M6ICdhc2MnLFxuICBTT1JUX0RFU0M6ICdkZXNjJyxcbiAgUk9XX1NFTEVDVF9TSU5HTEU6ICdyYWRpbycsXG4gIFJPV19TRUxFQ1RfTVVMVElQTEU6ICdjaGVja2JveCcsXG4gIFJPV19TRUxFQ1RfRElTQUJMRUQ6ICdST1dfU0VMRUNUX0RJU0FCTEVEJyxcbiAgQ0hFQ0tCT1hfU1RBVFVTX0NIRUNLRUQ6ICdjaGVja2VkJyxcbiAgQ0hFQ0tCT1hfU1RBVFVTX0lOREVURVJNSU5BVEU6ICdpbmRldGVybWluYXRlJyxcbiAgQ0hFQ0tCT1hfU1RBVFVTX1VOQ0hFQ0tFRDogJ3VuY2hlY2tlZCdcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb25zdC5qcyIsIi8qIGVzbGludCBuby1lbXB0eTogMCAqL1xuLyogZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOiAwICovXG4vKiBlc2xpbnQgcHJlZmVyLXJlc3QtcGFyYW1zOiAwICovXG5cbmZ1bmN0aW9uIHNwbGl0TmVzdGVkKHN0cikge1xuICByZXR1cm4gW3N0cl1cbiAgICAuam9pbignLicpXG4gICAgLnJlcGxhY2UoL1xcWy9nLCAnLicpXG4gICAgLnJlcGxhY2UoL1xcXS9nLCAnJylcbiAgICAuc3BsaXQoJy4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0KHRhcmdldCwgZmllbGQpIHtcbiAgY29uc3QgcGF0aEFycmF5ID0gc3BsaXROZXN0ZWQoZmllbGQpO1xuICBsZXQgcmVzdWx0O1xuICB0cnkge1xuICAgIHJlc3VsdCA9IHBhdGhBcnJheS5yZWR1Y2UoKGN1cnIsIHBhdGgpID0+IGN1cnJbcGF0aF0sIHRhcmdldCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIGZpZWxkLCB2YWx1ZSwgc2FmZSA9IGZhbHNlKSB7XG4gIGNvbnN0IHBhdGhBcnJheSA9IHNwbGl0TmVzdGVkKGZpZWxkKTtcbiAgbGV0IGxldmVsID0gMDtcbiAgcGF0aEFycmF5LnJlZHVjZSgoYSwgYikgPT4ge1xuICAgIGxldmVsICs9IDE7XG4gICAgaWYgKHR5cGVvZiBhW2JdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKCFzYWZlKSB0aHJvdyBuZXcgRXJyb3IoYCR7YX0uJHtifSBpcyB1bmRlZmluZWRgKTtcbiAgICAgIGFbYl0gPSB7fTtcbiAgICAgIHJldHVybiBhW2JdO1xuICAgIH1cblxuICAgIGlmIChsZXZlbCA9PT0gcGF0aEFycmF5Lmxlbmd0aCkge1xuICAgICAgYVtiXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYVtiXTtcbiAgfSwgdGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIE9iamVjdC4gdGhlIGBPYmplY3RgIGV4Y2VwdCBgRnVuY3Rpb25gIGFuZCBgQXJyYXkuYFxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGhlIHZhbHVlIGdvbm5hIGNoZWNrXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIG9iajtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlID09PSAnb2JqZWN0JyAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmopIHtcbiAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gZmFsc2U7XG5cbiAgY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBzbGVlcChmbiwgbXMpIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4gZm4oKSwgbXMpO1xufVxuXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgbGV0IHRpbWVvdXQ7XG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBsYXRlciA9ICgpID0+IHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuXG4gICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG5cbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgfHwgMCk7XG5cbiAgICBpZiAoY2FsbE5vdykge1xuICAgICAgZnVuYy5hcHB5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldCxcbiAgc2V0LFxuICBpc0Z1bmN0aW9uLFxuICBpc09iamVjdCxcbiAgaXNFbXB0eU9iamVjdCxcbiAgaXNEZWZpbmVkLFxuICBzbGVlcCxcbiAgZGVib3VuY2Vcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy91dGlscy5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBjb25zdCBCb290c3RyYXBDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIGJvb3RzdHJhcDQ6IGZhbHNlXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2NvbnRleHRzL2Jvb3RzdHJhcC5qcyIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTYgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXG5leHBvcnQgY29uc3QgbWF0Y2hSb3cgPSAoa2V5RmllbGQsIGlkKSA9PiByb3cgPT4gcm93W2tleUZpZWxkXSA9PT0gaWQ7XG5cbmV4cG9ydCBjb25zdCBnZXRSb3dCeVJvd0lkID0gKGRhdGEsIGtleUZpZWxkLCBpZCkgPT4gZGF0YS5maW5kKG1hdGNoUm93KGtleUZpZWxkLCBpZCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc3RvcmUvcm93cy5qcyIsImltcG9ydCBfIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldFJvd0J5Um93SWQgfSBmcm9tICcuL3Jvd3MnO1xuXG5leHBvcnQgY29uc3QgZ2V0U2VsZWN0aW9uU3VtbWFyeSA9IChcbiAgZGF0YSxcbiAga2V5RmllbGQsXG4gIHNlbGVjdGVkID0gW11cbikgPT4ge1xuICBsZXQgYWxsUm93c1NlbGVjdGVkID0gdHJ1ZTtcbiAgbGV0IGFsbFJvd3NOb3RTZWxlY3RlZCA9IHRydWU7XG5cbiAgY29uc3Qgcm93S2V5cyA9IGRhdGEubWFwKGQgPT4gZFtrZXlGaWVsZF0pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0tleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBjdXJyID0gcm93S2V5c1tpXTtcbiAgICBpZiAodHlwZW9mIHNlbGVjdGVkLmZpbmQoeCA9PiB4ID09PSBjdXJyKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGFsbFJvd3NTZWxlY3RlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbGxSb3dzTm90U2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhbGxSb3dzU2VsZWN0ZWQsXG4gICAgYWxsUm93c05vdFNlbGVjdGVkXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3Qgc2VsZWN0YWJsZUtleXMgPSAoZGF0YSwga2V5RmllbGQsIHNraXBzID0gW10pID0+IHtcbiAgaWYgKHNraXBzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBkYXRhLm1hcChyb3cgPT4gXy5nZXQocm93LCBrZXlGaWVsZCkpO1xuICB9XG4gIHJldHVybiBkYXRhXG4gICAgLmZpbHRlcihyb3cgPT4gIXNraXBzLmluY2x1ZGVzKF8uZ2V0KHJvdywga2V5RmllbGQpKSlcbiAgICAubWFwKHJvdyA9PiBfLmdldChyb3csIGtleUZpZWxkKSk7XG59O1xuXG5leHBvcnQgY29uc3QgdW5TZWxlY3RhYmxlS2V5cyA9IChzZWxlY3RlZCwgc2tpcHMgPSBbXSkgPT4ge1xuICBpZiAoc2tpcHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBzZWxlY3RlZC5maWx0ZXIoeCA9PiBza2lwcy5pbmNsdWRlcyh4KSk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2VsZWN0ZWRSb3dzID0gKGRhdGEsIGtleUZpZWxkLCBzZWxlY3RlZCkgPT5cbiAgc2VsZWN0ZWQubWFwKGsgPT4gZ2V0Um93QnlSb3dJZChkYXRhLCBrZXlGaWVsZCwgaykpO1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zdG9yZS9zZWxlY3Rpb24uanMiLCJpbXBvcnQgQm9vdHN0cmFwVGFibGUgZnJvbSAnLi9zcmMvYm9vdHN0cmFwLXRhYmxlJztcbmltcG9ydCB3aXRoQ29udGV4dCBmcm9tICcuL3NyYy9jb250ZXh0cyc7XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhDb250ZXh0KEJvb3RzdHJhcFRhYmxlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvaW5kZXguanMiLCIvKiBlc2xpbnQgYXJyb3ctYm9keS1zdHlsZTogMCAqL1xuXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjcyBmcm9tICdjbGFzc25hbWVzJztcblxuaW1wb3J0IEhlYWRlciBmcm9tICcuL2hlYWRlcic7XG5pbXBvcnQgQ2FwdGlvbiBmcm9tICcuL2NhcHRpb24nO1xuaW1wb3J0IEJvZHkgZnJvbSAnLi9ib2R5JztcbmltcG9ydCBQcm9wc0Jhc2VSZXNvbHZlciBmcm9tICcuL3Byb3BzLXJlc29sdmVyJztcbmltcG9ydCBDb25zdCBmcm9tICcuL2NvbnN0JztcbmltcG9ydCB7IGdldFNlbGVjdGlvblN1bW1hcnkgfSBmcm9tICcuL3N0b3JlL3NlbGVjdGlvbic7XG5cbmNsYXNzIEJvb3RzdHJhcFRhYmxlIGV4dGVuZHMgUHJvcHNCYXNlUmVzb2x2ZXIoQ29tcG9uZW50KSB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMudmFsaWRhdGVQcm9wcygpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgbG9hZGluZywgb3ZlcmxheSB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAob3ZlcmxheSkge1xuICAgICAgY29uc3QgTG9hZGluZ092ZXJsYXkgPSBvdmVybGF5KGxvYWRpbmcpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPExvYWRpbmdPdmVybGF5PlxuICAgICAgICAgIHsgdGhpcy5yZW5kZXJUYWJsZSgpIH1cbiAgICAgICAgPC9Mb2FkaW5nT3ZlcmxheT5cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbmRlclRhYmxlKCk7XG4gIH1cblxuICByZW5kZXJUYWJsZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgY29sdW1ucyxcbiAgICAgIGtleUZpZWxkLFxuICAgICAgaWQsXG4gICAgICBjbGFzc2VzLFxuICAgICAgc3RyaXBlZCxcbiAgICAgIGhvdmVyLFxuICAgICAgYm9yZGVyZWQsXG4gICAgICBjb25kZW5zZWQsXG4gICAgICBub0RhdGFJbmRpY2F0aW9uLFxuICAgICAgY2FwdGlvbixcbiAgICAgIHJvd1N0eWxlLFxuICAgICAgcm93Q2xhc3NlcyxcbiAgICAgIHdyYXBwZXJDbGFzc2VzLFxuICAgICAgcm93RXZlbnRzLFxuICAgICAgc2VsZWN0ZWRcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHRhYmxlV3JhcHBlckNsYXNzID0gY3MoJ3JlYWN0LWJvb3RzdHJhcC10YWJsZScsIHdyYXBwZXJDbGFzc2VzKTtcblxuICAgIGNvbnN0IHRhYmxlQ2xhc3MgPSBjcygndGFibGUnLCB7XG4gICAgICAndGFibGUtc3RyaXBlZCc6IHN0cmlwZWQsXG4gICAgICAndGFibGUtaG92ZXInOiBob3ZlcixcbiAgICAgICd0YWJsZS1ib3JkZXJlZCc6IGJvcmRlcmVkLFxuICAgICAgJ3RhYmxlLWNvbmRlbnNlZCc6IGNvbmRlbnNlZFxuICAgIH0sIGNsYXNzZXMpO1xuXG4gICAgY29uc3QgY2VsbFNlbGVjdGlvbkluZm8gPSB0aGlzLnJlc29sdmVTZWxlY3RSb3dQcm9wcyh7XG4gICAgICBvblJvd1NlbGVjdDogdGhpcy5wcm9wcy5vblJvd1NlbGVjdFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBhbGxSb3dzU2VsZWN0ZWQsIGFsbFJvd3NOb3RTZWxlY3RlZCB9ID0gZ2V0U2VsZWN0aW9uU3VtbWFyeShkYXRhLCBrZXlGaWVsZCwgc2VsZWN0ZWQpO1xuICAgIGNvbnN0IGhlYWRlckNlbGxTZWxlY3Rpb25JbmZvID0gdGhpcy5yZXNvbHZlU2VsZWN0Um93UHJvcHNGb3JIZWFkZXIoe1xuICAgICAgb25BbGxSb3dzU2VsZWN0OiB0aGlzLnByb3BzLm9uQWxsUm93c1NlbGVjdCxcbiAgICAgIHNlbGVjdGVkLFxuICAgICAgYWxsUm93c1NlbGVjdGVkLFxuICAgICAgYWxsUm93c05vdFNlbGVjdGVkXG4gICAgfSk7XG5cbiAgICBjb25zdCB0YWJsZUNhcHRpb24gPSAoY2FwdGlvbiAmJiA8Q2FwdGlvbj57IGNhcHRpb24gfTwvQ2FwdGlvbj4pO1xuICAgIGNvbnN0IGV4cGFuZFJvdyA9IHRoaXMucmVzb2x2ZUV4cGFuZFJvd1Byb3BzKCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9eyB0YWJsZVdyYXBwZXJDbGFzcyB9PlxuICAgICAgICA8dGFibGUgaWQ9eyBpZCB9IGNsYXNzTmFtZT17IHRhYmxlQ2xhc3MgfT5cbiAgICAgICAgICB7IHRhYmxlQ2FwdGlvbiB9XG4gICAgICAgICAgPEhlYWRlclxuICAgICAgICAgICAgY29sdW1ucz17IGNvbHVtbnMgfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXsgdGhpcy5wcm9wcy5oZWFkZXJDbGFzc2VzIH1cbiAgICAgICAgICAgIHNvcnRGaWVsZD17IHRoaXMucHJvcHMuc29ydEZpZWxkIH1cbiAgICAgICAgICAgIHNvcnRPcmRlcj17IHRoaXMucHJvcHMuc29ydE9yZGVyIH1cbiAgICAgICAgICAgIG9uU29ydD17IHRoaXMucHJvcHMub25Tb3J0IH1cbiAgICAgICAgICAgIG9uRmlsdGVyPXsgdGhpcy5wcm9wcy5vbkZpbHRlciB9XG4gICAgICAgICAgICBvbkV4dGVybmFsRmlsdGVyPXsgdGhpcy5wcm9wcy5vbkV4dGVybmFsRmlsdGVyIH1cbiAgICAgICAgICAgIHNlbGVjdFJvdz17IGhlYWRlckNlbGxTZWxlY3Rpb25JbmZvIH1cbiAgICAgICAgICAgIGV4cGFuZFJvdz17IGV4cGFuZFJvdyB9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8Qm9keVxuICAgICAgICAgICAgZGF0YT17IGRhdGEgfVxuICAgICAgICAgICAga2V5RmllbGQ9eyBrZXlGaWVsZCB9XG4gICAgICAgICAgICBjb2x1bW5zPXsgY29sdW1ucyB9XG4gICAgICAgICAgICBpc0VtcHR5PXsgdGhpcy5pc0VtcHR5KCkgfVxuICAgICAgICAgICAgdmlzaWJsZUNvbHVtblNpemU9eyB0aGlzLnZpc2libGVDb2x1bW5TaXplKCkgfVxuICAgICAgICAgICAgbm9EYXRhSW5kaWNhdGlvbj17IG5vRGF0YUluZGljYXRpb24gfVxuICAgICAgICAgICAgY2VsbEVkaXQ9eyB0aGlzLnByb3BzLmNlbGxFZGl0IHx8IHt9IH1cbiAgICAgICAgICAgIHNlbGVjdFJvdz17IGNlbGxTZWxlY3Rpb25JbmZvIH1cbiAgICAgICAgICAgIHNlbGVjdGVkUm93S2V5cz17IHNlbGVjdGVkIH1cbiAgICAgICAgICAgIGV4cGFuZFJvdz17IGV4cGFuZFJvdyB9XG4gICAgICAgICAgICByb3dTdHlsZT17IHJvd1N0eWxlIH1cbiAgICAgICAgICAgIHJvd0NsYXNzZXM9eyByb3dDbGFzc2VzIH1cbiAgICAgICAgICAgIHJvd0V2ZW50cz17IHJvd0V2ZW50cyB9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC90YWJsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuQm9vdHN0cmFwVGFibGUucHJvcFR5cGVzID0ge1xuICBrZXlGaWVsZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgY29sdW1uczogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIGJvb3RzdHJhcDQ6IFByb3BUeXBlcy5ib29sLFxuICByZW1vdGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHBhZ2luYXRpb246IFByb3BUeXBlcy5ib29sXG4gIH0pXSksXG4gIG5vRGF0YUluZGljYXRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gIHN0cmlwZWQ6IFByb3BUeXBlcy5ib29sLFxuICBib3JkZXJlZDogUHJvcFR5cGVzLmJvb2wsXG4gIGhvdmVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHdyYXBwZXJDbGFzc2VzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjb25kZW5zZWQ6IFByb3BUeXBlcy5ib29sLFxuICBjYXB0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMubm9kZSxcbiAgICBQcm9wVHlwZXMuc3RyaW5nXG4gIF0pLFxuICBwYWdpbmF0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICBmaWx0ZXI6IFByb3BUeXBlcy5vYmplY3QsXG4gIGNlbGxFZGl0OiBQcm9wVHlwZXMub2JqZWN0LFxuICBzZWxlY3RSb3c6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgbW9kZTogUHJvcFR5cGVzLm9uZU9mKFtDb25zdC5ST1dfU0VMRUNUX1NJTkdMRSwgQ29uc3QuUk9XX1NFTEVDVF9NVUxUSVBMRV0pLmlzUmVxdWlyZWQsXG4gICAgY2xpY2tUb1NlbGVjdDogUHJvcFR5cGVzLmJvb2wsXG4gICAgY2xpY2tUb0VkaXQ6IFByb3BUeXBlcy5ib29sLFxuICAgIG9uU2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblNlbGVjdEFsbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc3R5bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgY2xhc3NlczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBub25TZWxlY3RhYmxlOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgYmdDb2xvcjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBoaWRlU2VsZWN0Q29sdW1uOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBzZWxlY3Rpb25SZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2VsZWN0aW9uSGVhZGVyUmVuZGVyZXI6IFByb3BUeXBlcy5mdW5jXG4gIH0pLFxuICBvblJvd1NlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQWxsUm93c1NlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gIGV4cGFuZFJvdzogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICByZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBleHBhbmRlZDogUHJvcFR5cGVzLmFycmF5LFxuICAgIG9uRXhwYW5kOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkV4cGFuZEFsbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgbm9uRXhwYW5kYWJsZTogUHJvcFR5cGVzLmFycmF5LFxuICAgIHNob3dFeHBhbmRDb2x1bW46IFByb3BUeXBlcy5ib29sLFxuICAgIGV4cGFuZENvbHVtblJlbmRlcmVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBleHBhbmRIZWFkZXJDb2x1bW5SZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmNcbiAgfSksXG4gIG9uUm93RXhwYW5kOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25BbGxSb3dFeHBhbmQ6IFByb3BUeXBlcy5mdW5jLFxuICBpc0FueUV4cGFuZHM6IFByb3BUeXBlcy5mdW5jLFxuICByb3dTdHlsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgcm93RXZlbnRzOiBQcm9wVHlwZXMub2JqZWN0LFxuICByb3dDbGFzc2VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICBoZWFkZXJDbGFzc2VzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBkZWZhdWx0U29ydGVkOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGRhdGFGaWVsZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIG9yZGVyOiBQcm9wVHlwZXMub25lT2YoW0NvbnN0LlNPUlRfREVTQywgQ29uc3QuU09SVF9BU0NdKS5pc1JlcXVpcmVkXG4gIH0pKSxcbiAgZGVmYXVsdFNvcnREaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbQ29uc3QuU09SVF9ERVNDLCBDb25zdC5TT1JUX0FTQ10pLFxuICBvdmVybGF5OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25UYWJsZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uU29ydDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uRmlsdGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25FeHRlcm5hbEZpbHRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIC8vIEluamVjdCBmcm9tIHRvb2xraXRcbiAgc2VhcmNoOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHNlYXJjaFRleHQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgc2VhcmNoQ29udGV4dDogUHJvcFR5cGVzLmZ1bmNcbiAgfSksXG4gIHNldERlcGVuZGVuY3lNb2R1bGVzOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuQm9vdHN0cmFwVGFibGUuZGVmYXVsdFByb3BzID0ge1xuICBib290c3RyYXA0OiBmYWxzZSxcbiAgcmVtb3RlOiBmYWxzZSxcbiAgc3RyaXBlZDogZmFsc2UsXG4gIGJvcmRlcmVkOiB0cnVlLFxuICBob3ZlcjogZmFsc2UsXG4gIGNvbmRlbnNlZDogZmFsc2UsXG4gIG5vRGF0YUluZGljYXRpb246IG51bGxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJvb3RzdHJhcFRhYmxlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvYm9vdHN0cmFwLXRhYmxlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gIH07XG4gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH07XG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIGVzbGludCByZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHM6IDAgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbnN0IGZyb20gJy4vY29uc3QnO1xuXG5pbXBvcnQgSGVhZGVyQ2VsbCBmcm9tICcuL2hlYWRlci1jZWxsJztcbmltcG9ydCBTZWxlY3Rpb25IZWFkZXJDZWxsIGZyb20gJy4vcm93LXNlbGVjdGlvbi9zZWxlY3Rpb24taGVhZGVyLWNlbGwnO1xuaW1wb3J0IEV4cGFuZEhlYWRlckNlbGwgZnJvbSAnLi9yb3ctZXhwYW5kL2V4cGFuZC1oZWFkZXItY2VsbCc7XG5cbmNvbnN0IEhlYWRlciA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IFJPV19TRUxFQ1RfRElTQUJMRUQgfSA9IENvbnN0O1xuXG4gIGNvbnN0IHtcbiAgICBjbGFzc05hbWUsXG4gICAgY29sdW1ucyxcbiAgICBvblNvcnQsXG4gICAgb25GaWx0ZXIsXG4gICAgc29ydEZpZWxkLFxuICAgIHNvcnRPcmRlcixcbiAgICBzZWxlY3RSb3csXG4gICAgb25FeHRlcm5hbEZpbHRlcixcbiAgICBleHBhbmRSb3csXG4gICAgYm9vdHN0cmFwNFxuICB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIChcbiAgICA8dGhlYWQ+XG4gICAgICA8dHIgY2xhc3NOYW1lPXsgY2xhc3NOYW1lIH0+XG4gICAgICAgIHtcbiAgICAgICAgICAoZXhwYW5kUm93ICYmIGV4cGFuZFJvdy5zaG93RXhwYW5kQ29sdW1uKVxuICAgICAgICAgICAgPyA8RXhwYW5kSGVhZGVyQ2VsbFxuICAgICAgICAgICAgICBvbkFsbFJvd0V4cGFuZD17IGV4cGFuZFJvdy5vbkFsbFJvd0V4cGFuZCB9XG4gICAgICAgICAgICAgIGFueUV4cGFuZHM9eyBleHBhbmRSb3cuaXNBbnlFeHBhbmRzIH1cbiAgICAgICAgICAgICAgcmVuZGVyZXI9eyBleHBhbmRSb3cuZXhwYW5kSGVhZGVyQ29sdW1uUmVuZGVyZXIgfVxuICAgICAgICAgICAgLz4gOiBudWxsXG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIChzZWxlY3RSb3cubW9kZSAhPT0gUk9XX1NFTEVDVF9ESVNBQkxFRCAmJiAhc2VsZWN0Um93LmhpZGVTZWxlY3RDb2x1bW4pXG4gICAgICAgICAgICA/IDxTZWxlY3Rpb25IZWFkZXJDZWxsIHsgLi4uc2VsZWN0Um93IH0gLz4gOiBudWxsXG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIGNvbHVtbnMubWFwKChjb2x1bW4sIGkpID0+IHtcbiAgICAgICAgICAgIGlmICghY29sdW1uLmhpZGRlbikge1xuICAgICAgICAgICAgICBjb25zdCBjdXJyU29ydCA9IGNvbHVtbi5kYXRhRmllbGQgPT09IHNvcnRGaWVsZDtcbiAgICAgICAgICAgICAgY29uc3QgaXNMYXN0U29ydGluZyA9IGNvbHVtbi5kYXRhRmllbGQgPT09IHNvcnRGaWVsZDtcblxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxIZWFkZXJDZWxsXG4gICAgICAgICAgICAgICAgICBpbmRleD17IGkgfVxuICAgICAgICAgICAgICAgICAgYm9vdHN0cmFwND17IGJvb3RzdHJhcDQgfVxuICAgICAgICAgICAgICAgICAga2V5PXsgY29sdW1uLmRhdGFGaWVsZCB9XG4gICAgICAgICAgICAgICAgICBjb2x1bW49eyBjb2x1bW4gfVxuICAgICAgICAgICAgICAgICAgb25Tb3J0PXsgb25Tb3J0IH1cbiAgICAgICAgICAgICAgICAgIHNvcnRpbmc9eyBjdXJyU29ydCB9XG4gICAgICAgICAgICAgICAgICBvbkZpbHRlcj17IG9uRmlsdGVyIH1cbiAgICAgICAgICAgICAgICAgIG9uRXh0ZXJuYWxGaWx0ZXI9eyBvbkV4dGVybmFsRmlsdGVyIH1cbiAgICAgICAgICAgICAgICAgIHNvcnRPcmRlcj17IHNvcnRPcmRlciB9XG4gICAgICAgICAgICAgICAgICBpc0xhc3RTb3J0aW5nPXsgaXNMYXN0U29ydGluZyB9XG4gICAgICAgICAgICAgICAgLz4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIDwvdHI+XG4gICAgPC90aGVhZD5cbiAgKTtcbn07XG5cbkhlYWRlci5wcm9wVHlwZXMgPSB7XG4gIGNvbHVtbnM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBvblNvcnQ6IFByb3BUeXBlcy5mdW5jLFxuICBvbkZpbHRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvcnRGaWVsZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgc29ydE9yZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzZWxlY3RSb3c6IFByb3BUeXBlcy5vYmplY3QsXG4gIG9uRXh0ZXJuYWxGaWx0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGV4cGFuZFJvdzogUHJvcFR5cGVzLm9iamVjdCxcbiAgYm9vdHN0cmFwNDogUHJvcFR5cGVzLmJvb2xcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2hlYWRlci5qcyIsIi8qIGVzbGludCByZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHM6IDAgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3MgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5pbXBvcnQgQ29uc3QgZnJvbSAnLi9jb25zdCc7XG5pbXBvcnQgU29ydFN5bWJvbCBmcm9tICcuL3NvcnQvc3ltYm9sJztcbmltcG9ydCBTb3J0Q2FyZXQgZnJvbSAnLi9zb3J0L2NhcmV0JztcbmltcG9ydCBfIGZyb20gJy4vdXRpbHMnO1xuXG5cbmNvbnN0IEhlYWRlckNlbGwgPSAocHJvcHMpID0+IHtcbiAgY29uc3Qge1xuICAgIGNvbHVtbixcbiAgICBpbmRleCxcbiAgICBvblNvcnQsXG4gICAgc29ydGluZyxcbiAgICBzb3J0T3JkZXIsXG4gICAgaXNMYXN0U29ydGluZyxcbiAgICBvbkZpbHRlcixcbiAgICBvbkV4dGVybmFsRmlsdGVyXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCB7XG4gICAgdGV4dCxcbiAgICBzb3J0LFxuICAgIGZpbHRlcixcbiAgICBmaWx0ZXJSZW5kZXJlcixcbiAgICBoZWFkZXJUaXRsZSxcbiAgICBoZWFkZXJBbGlnbixcbiAgICBoZWFkZXJGb3JtYXR0ZXIsXG4gICAgaGVhZGVyRXZlbnRzLFxuICAgIGhlYWRlckNsYXNzZXMsXG4gICAgaGVhZGVyU3R5bGUsXG4gICAgaGVhZGVyQXR0cnMsXG4gICAgaGVhZGVyU29ydGluZ0NsYXNzZXMsXG4gICAgaGVhZGVyU29ydGluZ1N0eWxlXG4gIH0gPSBjb2x1bW47XG5cbiAgY29uc3QgY2VsbEF0dHJzID0ge1xuICAgIC4uLl8uaXNGdW5jdGlvbihoZWFkZXJBdHRycykgPyBoZWFkZXJBdHRycyhjb2x1bW4sIGluZGV4KSA6IGhlYWRlckF0dHJzLFxuICAgIC4uLmhlYWRlckV2ZW50c1xuICB9O1xuXG4gIGxldCBzb3J0U3ltYm9sO1xuICBsZXQgZmlsdGVyRWxtO1xuICBsZXQgY2VsbFN0eWxlID0ge307XG4gIGxldCBjZWxsQ2xhc3NlcyA9IF8uaXNGdW5jdGlvbihoZWFkZXJDbGFzc2VzKSA/IGhlYWRlckNsYXNzZXMoY29sdW1uLCBpbmRleCkgOiBoZWFkZXJDbGFzc2VzO1xuXG4gIGlmIChoZWFkZXJTdHlsZSkge1xuICAgIGNlbGxTdHlsZSA9IF8uaXNGdW5jdGlvbihoZWFkZXJTdHlsZSkgPyBoZWFkZXJTdHlsZShjb2x1bW4sIGluZGV4KSA6IGhlYWRlclN0eWxlO1xuICB9XG5cbiAgaWYgKGhlYWRlclRpdGxlKSB7XG4gICAgY2VsbEF0dHJzLnRpdGxlID0gXy5pc0Z1bmN0aW9uKGhlYWRlclRpdGxlKSA/IGhlYWRlclRpdGxlKGNvbHVtbiwgaW5kZXgpIDogdGV4dDtcbiAgfVxuXG4gIGlmIChoZWFkZXJBbGlnbikge1xuICAgIGNlbGxTdHlsZS50ZXh0QWxpZ24gPSBfLmlzRnVuY3Rpb24oaGVhZGVyQWxpZ24pID8gaGVhZGVyQWxpZ24oY29sdW1uLCBpbmRleCkgOiBoZWFkZXJBbGlnbjtcbiAgfVxuXG4gIGlmIChzb3J0KSB7XG4gICAgY29uc3QgY3VzdG9tQ2xpY2sgPSBjZWxsQXR0cnMub25DbGljaztcbiAgICBjZWxsQXR0cnMub25DbGljayA9IChlKSA9PiB7XG4gICAgICBvblNvcnQoY29sdW1uKTtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oY3VzdG9tQ2xpY2spKSBjdXN0b21DbGljayhlKTtcbiAgICB9O1xuICAgIGNlbGxBdHRycy5jbGFzc05hbWUgPSBjcyhjZWxsQXR0cnMuY2xhc3NOYW1lLCAnc29ydGFibGUnKTtcblxuICAgIGlmIChzb3J0aW5nKSB7XG4gICAgICBzb3J0U3ltYm9sID0gPFNvcnRDYXJldCBvcmRlcj17IHNvcnRPcmRlciB9IC8+O1xuXG4gICAgICAvLyBhcHBlbmQgY3VzdG9taXplZCBjbGFzc2VzIG9yIHN0eWxlIGlmIHRhYmxlIHdhcyBzb3J0aW5nIGJhc2VkIG9uIHRoZSBjdXJyZW50IGNvbHVtbi5cbiAgICAgIGNlbGxDbGFzc2VzID0gY3MoXG4gICAgICAgIGNlbGxDbGFzc2VzLFxuICAgICAgICBfLmlzRnVuY3Rpb24oaGVhZGVyU29ydGluZ0NsYXNzZXMpXG4gICAgICAgICAgPyBoZWFkZXJTb3J0aW5nQ2xhc3Nlcyhjb2x1bW4sIHNvcnRPcmRlciwgaXNMYXN0U29ydGluZywgaW5kZXgpXG4gICAgICAgICAgOiBoZWFkZXJTb3J0aW5nQ2xhc3Nlc1xuICAgICAgKTtcblxuICAgICAgY2VsbFN0eWxlID0ge1xuICAgICAgICAuLi5jZWxsU3R5bGUsXG4gICAgICAgIC4uLl8uaXNGdW5jdGlvbihoZWFkZXJTb3J0aW5nU3R5bGUpXG4gICAgICAgICAgPyBoZWFkZXJTb3J0aW5nU3R5bGUoY29sdW1uLCBzb3J0T3JkZXIsIGlzTGFzdFNvcnRpbmcsIGluZGV4KVxuICAgICAgICAgIDogaGVhZGVyU29ydGluZ1N0eWxlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3J0U3ltYm9sID0gPFNvcnRTeW1ib2wgLz47XG4gICAgfVxuICB9XG5cbiAgaWYgKGNlbGxDbGFzc2VzKSBjZWxsQXR0cnMuY2xhc3NOYW1lID0gY3MoY2VsbEF0dHJzLmNsYXNzTmFtZSwgY2VsbENsYXNzZXMpO1xuICBpZiAoIV8uaXNFbXB0eU9iamVjdChjZWxsU3R5bGUpKSBjZWxsQXR0cnMuc3R5bGUgPSBjZWxsU3R5bGU7XG5cbiAgaWYgKGZpbHRlclJlbmRlcmVyKSB7XG4gICAgY29uc3Qgb25DdXN0b21GaWx0ZXIgPSBvbkV4dGVybmFsRmlsdGVyKGNvbHVtbiwgZmlsdGVyLnByb3BzLnR5cGUpO1xuICAgIGZpbHRlckVsbSA9IGZpbHRlclJlbmRlcmVyKG9uQ3VzdG9tRmlsdGVyLCBjb2x1bW4pO1xuICB9IGVsc2UgaWYgKGZpbHRlcikge1xuICAgIGZpbHRlckVsbSA9IDxmaWx0ZXIuRmlsdGVyIHsgLi4uZmlsdGVyLnByb3BzIH0gb25GaWx0ZXI9eyBvbkZpbHRlciB9IGNvbHVtbj17IGNvbHVtbiB9IC8+O1xuICB9XG5cbiAgY29uc3QgY2hpbGRyZW4gPSBoZWFkZXJGb3JtYXR0ZXIgP1xuICAgIGhlYWRlckZvcm1hdHRlcihjb2x1bW4sIGluZGV4LCB7IHNvcnRFbGVtZW50OiBzb3J0U3ltYm9sLCBmaWx0ZXJFbGVtZW50OiBmaWx0ZXJFbG0gfSkgOlxuICAgIHRleHQ7XG5cbiAgaWYgKGhlYWRlckZvcm1hdHRlcikge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCd0aCcsIGNlbGxBdHRycywgY2hpbGRyZW4pO1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3RoJywgY2VsbEF0dHJzLCBjaGlsZHJlbiwgc29ydFN5bWJvbCwgZmlsdGVyRWxtKTtcbn07XG5cbkhlYWRlckNlbGwucHJvcFR5cGVzID0ge1xuICBjb2x1bW46IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgZGF0YUZpZWxkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgdGV4dDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGhpZGRlbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgaGVhZGVyRm9ybWF0dGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBmb3JtYXR0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIGZvcm1hdEV4dHJhRGF0YTogUHJvcFR5cGVzLmFueSxcbiAgICBoZWFkZXJDbGFzc2VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGNsYXNzZXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgaGVhZGVyU3R5bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgc3R5bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgaGVhZGVyVGl0bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIHRpdGxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBoZWFkZXJFdmVudHM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgZXZlbnRzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGhlYWRlckFsaWduOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGFsaWduOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGhlYWRlckF0dHJzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGF0dHJzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIHNvcnQ6IFByb3BUeXBlcy5ib29sLFxuICAgIHNvcnRGdW5jOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblNvcnQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIGVkaXRvcjogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBlZGl0YWJsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgZWRpdENlbGxTdHlsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBlZGl0Q2VsbENsYXNzZXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgZWRpdG9yU3R5bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgZWRpdG9yQ2xhc3NlczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBlZGl0b3JSZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgdmFsaWRhdG9yOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBmaWx0ZXI6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgZmlsdGVyUmVuZGVyZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIGZpbHRlclZhbHVlOiBQcm9wVHlwZXMuZnVuY1xuICB9KS5pc1JlcXVpcmVkLFxuICBpbmRleDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBvblNvcnQ6IFByb3BUeXBlcy5mdW5jLFxuICBzb3J0aW5nOiBQcm9wVHlwZXMuYm9vbCxcbiAgc29ydE9yZGVyOiBQcm9wVHlwZXMub25lT2YoW0NvbnN0LlNPUlRfQVNDLCBDb25zdC5TT1JUX0RFU0NdKSxcbiAgaXNMYXN0U29ydGluZzogUHJvcFR5cGVzLmJvb2wsXG4gIG9uRmlsdGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25FeHRlcm5hbEZpbHRlcjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRlckNlbGw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9oZWFkZXItY2VsbC5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBCb290c3RyYXBDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dHMvYm9vdHN0cmFwJztcblxuY29uc3QgU29ydFN5bWJvbCA9ICgpID0+IChcbiAgPEJvb3RzdHJhcENvbnRleHQuQ29uc3VtZXI+XG4gICAge1xuICAgICAgKHsgYm9vdHN0cmFwNCB9KSA9PiAoYm9vdHN0cmFwNCA/IChcbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwib3JkZXItNFwiIC8+XG4gICAgICApIDogKFxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJvcmRlclwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImRyb3Bkb3duXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJjYXJldFwiIC8+XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImRyb3B1cFwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiY2FyZXRcIiAvPlxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgKSlcbiAgICB9XG4gIDwvQm9vdHN0cmFwQ29udGV4dC5Db25zdW1lcj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFNvcnRTeW1ib2w7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zb3J0L3N5bWJvbC5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3MgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5pbXBvcnQgQ29uc3QgZnJvbSAnLi4vY29uc3QnO1xuaW1wb3J0IHsgQm9vdHN0cmFwQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHRzL2Jvb3RzdHJhcCc7XG5cblxuY29uc3QgU29ydENhcmV0ID0gKHsgb3JkZXIgfSkgPT4ge1xuICBjb25zdCBvcmRlckNsYXNzID0gY3MoJ3JlYWN0LWJvb3RzdHJhcC10YWJsZS1zb3J0LW9yZGVyJywge1xuICAgIGRyb3B1cDogb3JkZXIgPT09IENvbnN0LlNPUlRfQVNDXG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPEJvb3RzdHJhcENvbnRleHQuQ29uc3VtZXI+XG4gICAgICB7XG4gICAgICAgICh7IGJvb3RzdHJhcDQgfSkgPT4gKGJvb3RzdHJhcDQgPyAoXG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXsgYGNhcmV0LTQtJHtvcmRlcn1gIH0gLz5cbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9eyBvcmRlckNsYXNzIH0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJjYXJldFwiIC8+XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICApKVxuICAgICAgfVxuICAgIDwvQm9vdHN0cmFwQ29udGV4dC5Db25zdW1lcj5cbiAgKTtcbn07XG5cblNvcnRDYXJldC5wcm9wVHlwZXMgPSB7XG4gIG9yZGVyOiBQcm9wVHlwZXMub25lT2YoW0NvbnN0LlNPUlRfQVNDLCBDb25zdC5TT1JUX0RFU0NdKS5pc1JlcXVpcmVkXG59O1xuXG5leHBvcnQgZGVmYXVsdCBTb3J0Q2FyZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zb3J0L2NhcmV0LmpzIiwiLyogZXNsaW50IHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wczogMCAqL1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ29uc3QgZnJvbSAnLi4vY29uc3QnO1xuaW1wb3J0IHsgQm9vdHN0cmFwQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHRzL2Jvb3RzdHJhcCc7XG5cbmV4cG9ydCBjb25zdCBDaGVja0JveCA9ICh7IGNsYXNzTmFtZSwgY2hlY2tlZCwgaW5kZXRlcm1pbmF0ZSB9KSA9PiAoXG4gIDxpbnB1dFxuICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgY2hlY2tlZD17IGNoZWNrZWQgfVxuICAgIGNsYXNzTmFtZT17IGNsYXNzTmFtZSB9XG4gICAgcmVmPXsgKGlucHV0KSA9PiB7XG4gICAgICBpZiAoaW5wdXQpIGlucHV0LmluZGV0ZXJtaW5hdGUgPSBpbmRldGVybWluYXRlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgfSB9XG4gIC8+XG4pO1xuXG5DaGVja0JveC5wcm9wVHlwZXMgPSB7XG4gIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG4gIGluZGV0ZXJtaW5hdGU6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VsZWN0aW9uSGVhZGVyQ2VsbCBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgbW9kZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGNoZWNrZWRTdGF0dXM6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25BbGxSb3dzU2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBzZWxlY3Rpb25IZWFkZXJSZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmNcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5oYW5kbGVDaGVja0JveENsaWNrID0gdGhpcy5oYW5kbGVDaGVja0JveENsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogYXZvaWQgdXBkYXRpbmcgaWYgYnV0dG9uIGlzXG4gICAqIDEuIHJhZGlvXG4gICAqIDIuIHN0YXR1cyB3YXMgbm90IGNoYW5nZWQuXG4gICAqL1xuICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgY29uc3QgeyBST1dfU0VMRUNUX1NJTkdMRSB9ID0gQ29uc3Q7XG4gICAgY29uc3QgeyBtb2RlLCBjaGVja2VkU3RhdHVzIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKG1vZGUgPT09IFJPV19TRUxFQ1RfU0lOR0xFKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gbmV4dFByb3BzLmNoZWNrZWRTdGF0dXMgIT09IGNoZWNrZWRTdGF0dXM7XG4gIH1cblxuICBoYW5kbGVDaGVja0JveENsaWNrKGUpIHtcbiAgICBjb25zdCB7IG9uQWxsUm93c1NlbGVjdCwgY2hlY2tlZFN0YXR1cyB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBpc1VuU2VsZWN0ID1cbiAgICAgIGNoZWNrZWRTdGF0dXMgPT09IENvbnN0LkNIRUNLQk9YX1NUQVRVU19DSEVDS0VEIHx8XG4gICAgICBjaGVja2VkU3RhdHVzID09PSBDb25zdC5DSEVDS0JPWF9TVEFUVVNfSU5ERVRFUk1JTkFURTtcblxuICAgIG9uQWxsUm93c1NlbGVjdChlLCBpc1VuU2VsZWN0KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBDSEVDS0JPWF9TVEFUVVNfQ0hFQ0tFRCwgQ0hFQ0tCT1hfU1RBVFVTX0lOREVURVJNSU5BVEUsIFJPV19TRUxFQ1RfTVVMVElQTEVcbiAgICB9ID0gQ29uc3Q7XG5cbiAgICBjb25zdCB7IG1vZGUsIGNoZWNrZWRTdGF0dXMsIHNlbGVjdGlvbkhlYWRlclJlbmRlcmVyIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgY2hlY2tlZCA9IGNoZWNrZWRTdGF0dXMgPT09IENIRUNLQk9YX1NUQVRVU19DSEVDS0VEO1xuXG4gICAgY29uc3QgaW5kZXRlcm1pbmF0ZSA9IGNoZWNrZWRTdGF0dXMgPT09IENIRUNLQk9YX1NUQVRVU19JTkRFVEVSTUlOQVRFO1xuXG4gICAgY29uc3QgYXR0cnMgPSB7fTtcbiAgICBsZXQgY29udGVudDtcbiAgICBpZiAoc2VsZWN0aW9uSGVhZGVyUmVuZGVyZXIgfHwgbW9kZSA9PT0gUk9XX1NFTEVDVF9NVUxUSVBMRSkge1xuICAgICAgYXR0cnMub25DbGljayA9IHRoaXMuaGFuZGxlQ2hlY2tCb3hDbGljaztcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEJvb3RzdHJhcENvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgIHtcbiAgICAgICAgICAoeyBib290c3RyYXA0IH0pID0+IHtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25IZWFkZXJSZW5kZXJlcikge1xuICAgICAgICAgICAgICBjb250ZW50ID0gc2VsZWN0aW9uSGVhZGVyUmVuZGVyZXIoe1xuICAgICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgICAgY2hlY2tlZCxcbiAgICAgICAgICAgICAgICBpbmRldGVybWluYXRlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBST1dfU0VMRUNUX01VTFRJUExFKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSAoXG4gICAgICAgICAgICAgICAgPENoZWNrQm94XG4gICAgICAgICAgICAgICAgICB7IC4uLnRoaXMucHJvcHMgfVxuICAgICAgICAgICAgICAgICAgY2hlY2tlZD17IGNoZWNrZWQgfVxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXsgYm9vdHN0cmFwNCA/ICdzZWxlY3Rpb24taW5wdXQtNCcgOiAnJyB9XG4gICAgICAgICAgICAgICAgICBpbmRldGVybWluYXRlPXsgaW5kZXRlcm1pbmF0ZSB9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIDx0aCBkYXRhLXJvdy1zZWxlY3Rpb24geyAuLi5hdHRycyB9PnsgY29udGVudCB9PC90aD5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICA8L0Jvb3RzdHJhcENvbnRleHQuQ29uc3VtZXI+XG4gICAgKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LXNlbGVjdGlvbi9zZWxlY3Rpb24taGVhZGVyLWNlbGwuanMiLCIvKiBlc2xpbnQgcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzOiAwICovXG4vKiBlc2xpbnQgbm8tbmVzdGVkLXRlcm5hcnk6IDAgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3Rpb25IZWFkZXJDZWxsIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBhbnlFeHBhbmRzOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAgIG9uQWxsUm93RXhwYW5kOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHJlbmRlcmVyOiBQcm9wVHlwZXMuZnVuY1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmhhbmRsZUNoZWNrQm94Q2xpY2sgPSB0aGlzLmhhbmRsZUNoZWNrQm94Q2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIGhhbmRsZUNoZWNrQm94Q2xpY2soZSkge1xuICAgIGNvbnN0IHsgYW55RXhwYW5kcywgb25BbGxSb3dFeHBhbmQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBvbkFsbFJvd0V4cGFuZChlLCAhYW55RXhwYW5kcyk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBhbnlFeHBhbmRzLCByZW5kZXJlciB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBhdHRycyA9IHtcbiAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2hlY2tCb3hDbGlja1xuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgPHRoIGRhdGEtcm93LXNlbGVjdGlvbiB7IC4uLmF0dHJzIH0+XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJlciA/XG4gICAgICAgICAgICByZW5kZXJlcih7IGlzQW55RXhwYW5kczogYW55RXhwYW5kcyB9KSA6XG4gICAgICAgICAgICAoYW55RXhwYW5kcyA/ICcoLSknIDogJygrKScpXG4gICAgICAgIH1cbiAgICAgIDwvdGg+XG4gICAgKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LWV4cGFuZC9leHBhbmQtaGVhZGVyLWNlbGwuanMiLCIvKiBlc2xpbnQgcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzOiAwICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY29uc3QgQ2FwdGlvbiA9IChwcm9wcykgPT4ge1xuICBpZiAoIXByb3BzLmNoaWxkcmVuKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIChcbiAgICA8Y2FwdGlvbj57IHByb3BzLmNoaWxkcmVuIH08L2NhcHRpb24+XG4gICk7XG59O1xuXG5DYXB0aW9uLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgIFByb3BUeXBlcy5ub2RlLFxuICAgIFByb3BUeXBlcy5zdHJpbmdcbiAgXSlcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENhcHRpb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jYXB0aW9uLmpzIiwiLyogZXNsaW50IHJlYWN0L3Byb3AtdHlwZXM6IDAgKi9cbi8qIGVzbGludCByZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHM6IDAgKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3MgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCBfIGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IFJvdyBmcm9tICcuL3Jvdyc7XG5pbXBvcnQgRXhwYW5kUm93IGZyb20gJy4vcm93LWV4cGFuZC9leHBhbmQtcm93JztcbmltcG9ydCBSb3dTZWN0aW9uIGZyb20gJy4vcm93LXNlY3Rpb24nO1xuaW1wb3J0IENvbnN0IGZyb20gJy4vY29uc3QnO1xuXG5jb25zdCBCb2R5ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb2x1bW5zLFxuICAgIGRhdGEsXG4gICAga2V5RmllbGQsXG4gICAgaXNFbXB0eSxcbiAgICBub0RhdGFJbmRpY2F0aW9uLFxuICAgIHZpc2libGVDb2x1bW5TaXplLFxuICAgIGNlbGxFZGl0LFxuICAgIHNlbGVjdFJvdyxcbiAgICBzZWxlY3RlZFJvd0tleXMsXG4gICAgcm93U3R5bGUsXG4gICAgcm93Q2xhc3NlcyxcbiAgICByb3dFdmVudHMsXG4gICAgZXhwYW5kUm93XG4gIH0gPSBwcm9wcztcblxuICBjb25zdCB7XG4gICAgYmdDb2xvcixcbiAgICBub25TZWxlY3RhYmxlXG4gIH0gPSBzZWxlY3RSb3c7XG5cbiAgbGV0IGNvbnRlbnQ7XG5cbiAgaWYgKGlzRW1wdHkpIHtcbiAgICBjb25zdCBpbmRpY2F0aW9uID0gXy5pc0Z1bmN0aW9uKG5vRGF0YUluZGljYXRpb24pID8gbm9EYXRhSW5kaWNhdGlvbigpIDogbm9EYXRhSW5kaWNhdGlvbjtcbiAgICBpZiAoIWluZGljYXRpb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb250ZW50ID0gPFJvd1NlY3Rpb24gY29udGVudD17IGluZGljYXRpb24gfSBjb2xTcGFuPXsgdmlzaWJsZUNvbHVtblNpemUgfSAvPjtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBub25FZGl0YWJsZVJvd3MgPSBjZWxsRWRpdC5ub25FZGl0YWJsZVJvd3MgfHwgW107XG4gICAgY29udGVudCA9IGRhdGEubWFwKChyb3csIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBfLmdldChyb3csIGtleUZpZWxkKTtcbiAgICAgIGNvbnN0IGVkaXRhYmxlID0gIShub25FZGl0YWJsZVJvd3MubGVuZ3RoID4gMCAmJiBub25FZGl0YWJsZVJvd3MuaW5kZXhPZihrZXkpID4gLTEpO1xuXG4gICAgICBjb25zdCBzZWxlY3RlZCA9IHNlbGVjdFJvdy5tb2RlICE9PSBDb25zdC5ST1dfU0VMRUNUX0RJU0FCTEVEXG4gICAgICAgID8gc2VsZWN0ZWRSb3dLZXlzLmluY2x1ZGVzKGtleSlcbiAgICAgICAgOiBudWxsO1xuXG4gICAgICBjb25zdCBhdHRycyA9IHJvd0V2ZW50cyB8fCB7fTtcbiAgICAgIGxldCBzdHlsZSA9IF8uaXNGdW5jdGlvbihyb3dTdHlsZSkgPyByb3dTdHlsZShyb3csIGluZGV4KSA6IHJvd1N0eWxlO1xuICAgICAgbGV0IGNsYXNzZXMgPSAoXy5pc0Z1bmN0aW9uKHJvd0NsYXNzZXMpID8gcm93Q2xhc3Nlcyhyb3csIGluZGV4KSA6IHJvd0NsYXNzZXMpO1xuICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkU3R5bGUgPSBfLmlzRnVuY3Rpb24oc2VsZWN0Um93LnN0eWxlKVxuICAgICAgICAgID8gc2VsZWN0Um93LnN0eWxlKHJvdywgaW5kZXgpXG4gICAgICAgICAgOiBzZWxlY3RSb3cuc3R5bGU7XG5cbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRDbGFzc2VzID0gXy5pc0Z1bmN0aW9uKHNlbGVjdFJvdy5jbGFzc2VzKVxuICAgICAgICAgID8gc2VsZWN0Um93LmNsYXNzZXMocm93LCBpbmRleClcbiAgICAgICAgICA6IHNlbGVjdFJvdy5jbGFzc2VzO1xuXG4gICAgICAgIHN0eWxlID0ge1xuICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgIC4uLnNlbGVjdGVkU3R5bGVcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NlcyA9IGNzKGNsYXNzZXMsIHNlbGVjdGVkQ2xhc3Nlcyk7XG5cbiAgICAgICAgaWYgKGJnQ29sb3IpIHtcbiAgICAgICAgICBzdHlsZSA9IHN0eWxlIHx8IHt9O1xuICAgICAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9IF8uaXNGdW5jdGlvbihiZ0NvbG9yKSA/IGJnQ29sb3Iocm93LCBpbmRleCkgOiBiZ0NvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlbGVjdGFibGUgPSAhbm9uU2VsZWN0YWJsZSB8fCAhbm9uU2VsZWN0YWJsZS5pbmNsdWRlcyhrZXkpO1xuICAgICAgY29uc3QgZXhwYW5kYWJsZSA9IGV4cGFuZFJvdyAmJiAhZXhwYW5kUm93Lm5vbkV4cGFuZGFibGUuaW5jbHVkZXMoa2V5KTtcbiAgICAgIGNvbnN0IGV4cGFuZGVkID0gZXhwYW5kUm93ICYmIGV4cGFuZFJvdy5leHBhbmRlZC5pbmNsdWRlcyhrZXkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBbXG4gICAgICAgIDxSb3dcbiAgICAgICAgICBrZXk9eyBrZXkgfVxuICAgICAgICAgIHJvdz17IHJvdyB9XG4gICAgICAgICAga2V5RmllbGQ9eyBrZXlGaWVsZCB9XG4gICAgICAgICAgcm93SW5kZXg9eyBpbmRleCB9XG4gICAgICAgICAgY29sdW1ucz17IGNvbHVtbnMgfVxuICAgICAgICAgIGNlbGxFZGl0PXsgY2VsbEVkaXQgfVxuICAgICAgICAgIGVkaXRhYmxlPXsgZWRpdGFibGUgfVxuICAgICAgICAgIHNlbGVjdGFibGU9eyBzZWxlY3RhYmxlIH1cbiAgICAgICAgICBleHBhbmRhYmxlPXsgZXhwYW5kYWJsZSB9XG4gICAgICAgICAgc2VsZWN0ZWQ9eyBzZWxlY3RlZCB9XG4gICAgICAgICAgZXhwYW5kZWQ9eyBleHBhbmRlZCB9XG4gICAgICAgICAgc2VsZWN0Um93PXsgc2VsZWN0Um93IH1cbiAgICAgICAgICBleHBhbmRSb3c9eyBleHBhbmRSb3cgfVxuICAgICAgICAgIHN0eWxlPXsgc3R5bGUgfVxuICAgICAgICAgIGNsYXNzTmFtZT17IGNsYXNzZXMgfVxuICAgICAgICAgIGF0dHJzPXsgYXR0cnMgfVxuICAgICAgICAvPlxuICAgICAgXTtcblxuICAgICAgaWYgKGV4cGFuZGVkKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKChcbiAgICAgICAgICA8RXhwYW5kUm93XG4gICAgICAgICAgICBrZXk9eyBgJHtrZXl9LWV4cGFuZGluZ2AgfVxuICAgICAgICAgICAgY29sU3Bhbj17IHZpc2libGVDb2x1bW5TaXplIH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7IGV4cGFuZFJvdy5yZW5kZXJlcihyb3cpIH1cbiAgICAgICAgICA8L0V4cGFuZFJvdz5cbiAgICAgICAgKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDx0Ym9keT57IGNvbnRlbnQgfTwvdGJvZHk+XG4gICk7XG59O1xuXG5Cb2R5LnByb3BUeXBlcyA9IHtcbiAga2V5RmllbGQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIGNvbHVtbnM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBzZWxlY3RSb3c6IFByb3BUeXBlcy5vYmplY3QsXG4gIHNlbGVjdGVkUm93S2V5czogUHJvcFR5cGVzLmFycmF5XG59O1xuXG5leHBvcnQgZGVmYXVsdCBCb2R5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvYm9keS5qcyIsIi8qIGVzbGludCByZWFjdC9wcm9wLXR5cGVzOiAwICovXG4vKiBlc2xpbnQgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5OiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0IF8gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgQ2VsbCBmcm9tICcuL2NlbGwnO1xuaW1wb3J0IFNlbGVjdGlvbkNlbGwgZnJvbSAnLi9yb3ctc2VsZWN0aW9uL3NlbGVjdGlvbi1jZWxsJztcbmltcG9ydCBFeHBhbmRDZWxsIGZyb20gJy4vcm93LWV4cGFuZC9leHBhbmQtY2VsbCc7XG5pbXBvcnQgZXZlbnREZWxlZ2F0ZXIgZnJvbSAnLi9yb3ctZXZlbnQtZGVsZWdhdGVyJztcbmltcG9ydCBDb25zdCBmcm9tICcuL2NvbnN0JztcblxuY2xhc3MgUm93IGV4dGVuZHMgZXZlbnREZWxlZ2F0ZXIoQ29tcG9uZW50KSB7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICByb3csXG4gICAgICBjb2x1bW5zLFxuICAgICAga2V5RmllbGQsXG4gICAgICByb3dJbmRleCxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIHN0eWxlLFxuICAgICAgYXR0cnMsXG4gICAgICBjZWxsRWRpdCxcbiAgICAgIHNlbGVjdGVkLFxuICAgICAgc2VsZWN0Um93LFxuICAgICAgZXhwYW5kZWQsXG4gICAgICBleHBhbmRSb3csXG4gICAgICBzZWxlY3RhYmxlLFxuICAgICAgZWRpdGFibGU6IGVkaXRhYmxlUm93XG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCB7XG4gICAgICBtb2RlLFxuICAgICAgb25TdGFydCxcbiAgICAgIEVkaXRpbmdDZWxsLFxuICAgICAgcmlkeDogZWRpdGluZ1Jvd0lkeCxcbiAgICAgIGNpZHg6IGVkaXRpbmdDb2xJZHgsXG4gICAgICBDTElDS19UT19DRUxMX0VESVQsXG4gICAgICBEQkNMSUNLX1RPX0NFTExfRURJVCxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gY2VsbEVkaXQ7XG5cbiAgICBjb25zdCBrZXkgPSBfLmdldChyb3csIGtleUZpZWxkKTtcbiAgICBjb25zdCB7IGhpZGVTZWxlY3RDb2x1bW4gfSA9IHNlbGVjdFJvdztcbiAgICBjb25zdCB7IHNob3dFeHBhbmRDb2x1bW4gfSA9IGV4cGFuZFJvdyB8fCB7fTtcbiAgICBjb25zdCB0ckF0dHJzID0gdGhpcy5kZWxlZ2F0ZShhdHRycyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPHRyIHN0eWxlPXsgc3R5bGUgfSBjbGFzc05hbWU9eyBjbGFzc05hbWUgfSB7IC4uLnRyQXR0cnMgfT5cbiAgICAgICAge1xuICAgICAgICAgIHNob3dFeHBhbmRDb2x1bW4gPyAoXG4gICAgICAgICAgICA8RXhwYW5kQ2VsbFxuICAgICAgICAgICAgICB7IC4uLmV4cGFuZFJvdyB9XG4gICAgICAgICAgICAgIHJvd0tleT17IGtleSB9XG4gICAgICAgICAgICAgIHJvd0luZGV4PXsgcm93SW5kZXggfVxuICAgICAgICAgICAgICBleHBhbmRlZD17IGV4cGFuZGVkIH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSA6IG51bGxcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgKHNlbGVjdFJvdy5tb2RlICE9PSBDb25zdC5ST1dfU0VMRUNUX0RJU0FCTEVEICYmICFoaWRlU2VsZWN0Q29sdW1uKVxuICAgICAgICAgICAgPyAoXG4gICAgICAgICAgICAgIDxTZWxlY3Rpb25DZWxsXG4gICAgICAgICAgICAgICAgeyAuLi5zZWxlY3RSb3cgfVxuICAgICAgICAgICAgICAgIHJvd0tleT17IGtleSB9XG4gICAgICAgICAgICAgICAgcm93SW5kZXg9eyByb3dJbmRleCB9XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ9eyBzZWxlY3RlZCB9XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyAhc2VsZWN0YWJsZSB9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApXG4gICAgICAgICAgICA6IG51bGxcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgY29sdW1ucy5tYXAoKGNvbHVtbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmICghY29sdW1uLmhpZGRlbikge1xuICAgICAgICAgICAgICBjb25zdCB7IGRhdGFGaWVsZCB9ID0gY29sdW1uO1xuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gXy5nZXQocm93LCBkYXRhRmllbGQpO1xuICAgICAgICAgICAgICBsZXQgZWRpdGFibGUgPSBfLmlzRGVmaW5lZChjb2x1bW4uZWRpdGFibGUpID8gY29sdW1uLmVkaXRhYmxlIDogdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKGRhdGFGaWVsZCA9PT0ga2V5RmllbGQgfHwgIWVkaXRhYmxlUm93KSBlZGl0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNvbHVtbi5lZGl0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICBlZGl0YWJsZSA9IGNvbHVtbi5lZGl0YWJsZShjb250ZW50LCByb3csIHJvd0luZGV4LCBpbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJvd0luZGV4ID09PSBlZGl0aW5nUm93SWR4ICYmIGluZGV4ID09PSBlZGl0aW5nQ29sSWR4KSB7XG4gICAgICAgICAgICAgICAgbGV0IGVkaXRDZWxsc3R5bGUgPSBjb2x1bW4uZWRpdENlbGxTdHlsZSB8fCB7fTtcbiAgICAgICAgICAgICAgICBsZXQgZWRpdENlbGxjbGFzc2VzID0gY29sdW1uLmVkaXRDZWxsQ2xhc3NlcztcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNvbHVtbi5lZGl0Q2VsbFN0eWxlKSkge1xuICAgICAgICAgICAgICAgICAgZWRpdENlbGxzdHlsZSA9IGNvbHVtbi5lZGl0Q2VsbFN0eWxlKGNvbnRlbnQsIHJvdywgcm93SW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihjb2x1bW4uZWRpdENlbGxDbGFzc2VzKSkge1xuICAgICAgICAgICAgICAgICAgZWRpdENlbGxjbGFzc2VzID0gY29sdW1uLmVkaXRDZWxsQ2xhc3Nlcyhjb250ZW50LCByb3csIHJvd0luZGV4LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICA8RWRpdGluZ0NlbGxcbiAgICAgICAgICAgICAgICAgICAga2V5PXsgYCR7Y29udGVudH0tJHtpbmRleH1gIH1cbiAgICAgICAgICAgICAgICAgICAgcm93PXsgcm93IH1cbiAgICAgICAgICAgICAgICAgICAgcm93SW5kZXg9eyByb3dJbmRleCB9XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbj17IGNvbHVtbiB9XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4PXsgaW5kZXggfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9eyBlZGl0Q2VsbGNsYXNzZXMgfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17IGVkaXRDZWxsc3R5bGUgfVxuICAgICAgICAgICAgICAgICAgICB7IC4uLnJlc3QgfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPENlbGxcbiAgICAgICAgICAgICAgICAgIGtleT17IGAke2NvbnRlbnR9LSR7aW5kZXh9YCB9XG4gICAgICAgICAgICAgICAgICByb3c9eyByb3cgfVxuICAgICAgICAgICAgICAgICAgcm93SW5kZXg9eyByb3dJbmRleCB9XG4gICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleD17IGluZGV4IH1cbiAgICAgICAgICAgICAgICAgIGNvbHVtbj17IGNvbHVtbiB9XG4gICAgICAgICAgICAgICAgICBvblN0YXJ0PXsgb25TdGFydCB9XG4gICAgICAgICAgICAgICAgICBlZGl0YWJsZT17IGVkaXRhYmxlIH1cbiAgICAgICAgICAgICAgICAgIGNsaWNrVG9FZGl0PXsgbW9kZSA9PT0gQ0xJQ0tfVE9fQ0VMTF9FRElUIH1cbiAgICAgICAgICAgICAgICAgIGRiY2xpY2tUb0VkaXQ9eyBtb2RlID09PSBEQkNMSUNLX1RPX0NFTExfRURJVCB9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICA8L3RyPlxuICAgICk7XG4gIH1cbn1cblxuUm93LnByb3BUeXBlcyA9IHtcbiAgcm93OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIHJvd0luZGV4OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGNvbHVtbnM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBhdHRyczogUHJvcFR5cGVzLm9iamVjdFxufTtcblxuUm93LmRlZmF1bHRQcm9wcyA9IHtcbiAgZWRpdGFibGU6IHRydWUsXG4gIHN0eWxlOiB7fSxcbiAgY2xhc3NOYW1lOiBudWxsLFxuICBhdHRyczoge31cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFJvdztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy5qcyIsIi8qIGVzbGludCByZWFjdC9wcm9wLXR5cGVzOiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0IF8gZnJvbSAnLi91dGlscyc7XG5cbmNsYXNzIENlbGwgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLmhhbmRsZUVkaXRpbmdDZWxsID0gdGhpcy5oYW5kbGVFZGl0aW5nQ2VsbC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgaGFuZGxlRWRpdGluZ0NlbGwoZSkge1xuICAgIGNvbnN0IHsgY29sdW1uLCBvblN0YXJ0LCByb3dJbmRleCwgY29sdW1uSW5kZXgsIGNsaWNrVG9FZGl0LCBkYmNsaWNrVG9FZGl0IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgZXZlbnRzIH0gPSBjb2x1bW47XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgaWYgKGNsaWNrVG9FZGl0KSB7XG4gICAgICAgIGNvbnN0IGN1c3RvbUNsaWNrID0gZXZlbnRzLm9uQ2xpY2s7XG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oY3VzdG9tQ2xpY2spKSBjdXN0b21DbGljayhlKTtcbiAgICAgIH0gZWxzZSBpZiAoZGJjbGlja1RvRWRpdCkge1xuICAgICAgICBjb25zdCBjdXN0b21EYkNsaWNrID0gZXZlbnRzLm9uRG91YmxlQ2xpY2s7XG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oY3VzdG9tRGJDbGljaykpIGN1c3RvbURiQ2xpY2soZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvblN0YXJ0KSB7XG4gICAgICBvblN0YXJ0KHJvd0luZGV4LCBjb2x1bW5JbmRleCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJvdyxcbiAgICAgIHJvd0luZGV4LFxuICAgICAgY29sdW1uLFxuICAgICAgY29sdW1uSW5kZXgsXG4gICAgICBlZGl0YWJsZSxcbiAgICAgIGNsaWNrVG9FZGl0LFxuICAgICAgZGJjbGlja1RvRWRpdFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFGaWVsZCxcbiAgICAgIGZvcm1hdHRlcixcbiAgICAgIGZvcm1hdEV4dHJhRGF0YSxcbiAgICAgIHN0eWxlLFxuICAgICAgY2xhc3NlcyxcbiAgICAgIHRpdGxlLFxuICAgICAgZXZlbnRzLFxuICAgICAgYWxpZ24sXG4gICAgICBhdHRyc1xuICAgIH0gPSBjb2x1bW47XG4gICAgbGV0IGNlbGxUaXRsZTtcbiAgICBsZXQgY2VsbFN0eWxlID0ge307XG4gICAgbGV0IGNvbnRlbnQgPSBfLmdldChyb3csIGRhdGFGaWVsZCk7XG5cbiAgICBjb25zdCBjZWxsQXR0cnMgPSB7XG4gICAgICAuLi5fLmlzRnVuY3Rpb24oYXR0cnMpID8gYXR0cnMoY29udGVudCwgcm93LCByb3dJbmRleCwgY29sdW1uSW5kZXgpIDogYXR0cnMsXG4gICAgICAuLi5ldmVudHNcbiAgICB9O1xuXG4gICAgY29uc3QgY2VsbENsYXNzZXMgPSBfLmlzRnVuY3Rpb24oY2xhc3NlcylcbiAgICAgID8gY2xhc3Nlcyhjb250ZW50LCByb3csIHJvd0luZGV4LCBjb2x1bW5JbmRleClcbiAgICAgIDogY2xhc3NlcztcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgY2VsbFN0eWxlID0gXy5pc0Z1bmN0aW9uKHN0eWxlKSA/IHN0eWxlKGNvbnRlbnQsIHJvdywgcm93SW5kZXgsIGNvbHVtbkluZGV4KSA6IHN0eWxlO1xuICAgIH1cblxuICAgIGlmICh0aXRsZSkge1xuICAgICAgY2VsbFRpdGxlID0gXy5pc0Z1bmN0aW9uKHRpdGxlKSA/IHRpdGxlKGNvbnRlbnQsIHJvdywgcm93SW5kZXgsIGNvbHVtbkluZGV4KSA6IGNvbnRlbnQ7XG4gICAgICBjZWxsQXR0cnMudGl0bGUgPSBjZWxsVGl0bGU7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgY29udGVudCA9IGNvbHVtbi5mb3JtYXR0ZXIoY29udGVudCwgcm93LCByb3dJbmRleCwgZm9ybWF0RXh0cmFEYXRhKTtcbiAgICB9XG5cbiAgICBpZiAoYWxpZ24pIHtcbiAgICAgIGNlbGxTdHlsZS50ZXh0QWxpZ24gPVxuICAgICAgICBfLmlzRnVuY3Rpb24oYWxpZ24pID8gYWxpZ24oY29udGVudCwgcm93LCByb3dJbmRleCwgY29sdW1uSW5kZXgpIDogYWxpZ247XG4gICAgfVxuXG4gICAgaWYgKGNlbGxDbGFzc2VzKSBjZWxsQXR0cnMuY2xhc3NOYW1lID0gY2VsbENsYXNzZXM7XG5cbiAgICBpZiAoIV8uaXNFbXB0eU9iamVjdChjZWxsU3R5bGUpKSBjZWxsQXR0cnMuc3R5bGUgPSBjZWxsU3R5bGU7XG4gICAgaWYgKGNsaWNrVG9FZGl0ICYmIGVkaXRhYmxlKSB7XG4gICAgICBjZWxsQXR0cnMub25DbGljayA9IHRoaXMuaGFuZGxlRWRpdGluZ0NlbGw7XG4gICAgfSBlbHNlIGlmIChkYmNsaWNrVG9FZGl0ICYmIGVkaXRhYmxlKSB7XG4gICAgICBjZWxsQXR0cnMub25Eb3VibGVDbGljayA9IHRoaXMuaGFuZGxlRWRpdGluZ0NlbGw7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICA8dGQgeyAuLi5jZWxsQXR0cnMgfT5cbiAgICAgICAgeyB0eXBlb2YgY29udGVudCA9PT0gJ2Jvb2xlYW4nID8gYCR7Y29udGVudH1gIDogY29udGVudCB9XG4gICAgICA8L3RkPlxuICAgICk7XG4gIH1cbn1cblxuQ2VsbC5wcm9wVHlwZXMgPSB7XG4gIHJvdzogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICByb3dJbmRleDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBjb2x1bW46IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgY29sdW1uSW5kZXg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQ2VsbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2NlbGwuanMiLCIvKiBlc2xpbnRcbiAgcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzOiAwXG4gIGpzeC1hMTF5L25vLW5vbmludGVyYWN0aXZlLWVsZW1lbnQtaW50ZXJhY3Rpb25zOiAwXG4qL1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ29uc3QgZnJvbSAnLi4vY29uc3QnO1xuaW1wb3J0IHsgQm9vdHN0cmFwQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHRzL2Jvb3RzdHJhcCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbGVjdGlvbkNlbGwgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIG1vZGU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICByb3dLZXk6IFByb3BUeXBlcy5hbnksXG4gICAgc2VsZWN0ZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIG9uUm93U2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgcm93SW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgY2xpY2tUb1NlbGVjdDogUHJvcFR5cGVzLmJvb2wsXG4gICAgc2VsZWN0aW9uUmVuZGVyZXI6IFByb3BUeXBlcy5mdW5jXG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaGFuZGxlQ2xpY2sgPSB0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgY29uc3QgeyBzZWxlY3RlZCB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiBuZXh0UHJvcHMuc2VsZWN0ZWQgIT09IHNlbGVjdGVkO1xuICB9XG5cbiAgaGFuZGxlQ2xpY2soZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1vZGU6IGlucHV0VHlwZSxcbiAgICAgIHJvd0tleSxcbiAgICAgIHNlbGVjdGVkLFxuICAgICAgb25Sb3dTZWxlY3QsXG4gICAgICBkaXNhYmxlZCxcbiAgICAgIHJvd0luZGV4LFxuICAgICAgY2xpY2tUb1NlbGVjdFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgaWYgKGNsaWNrVG9TZWxlY3QpIHJldHVybjtcblxuICAgIGNvbnN0IGNoZWNrZWQgPSBpbnB1dFR5cGUgPT09IENvbnN0LlJPV19TRUxFQ1RfU0lOR0xFXG4gICAgICA/IHRydWVcbiAgICAgIDogIXNlbGVjdGVkO1xuXG4gICAgb25Sb3dTZWxlY3Qocm93S2V5LCBjaGVja2VkLCByb3dJbmRleCwgZSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbW9kZTogaW5wdXRUeXBlLFxuICAgICAgc2VsZWN0ZWQsXG4gICAgICBkaXNhYmxlZCxcbiAgICAgIHNlbGVjdGlvblJlbmRlcmVyXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEJvb3RzdHJhcENvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgIHtcbiAgICAgICAgICAoeyBib290c3RyYXA0IH0pID0+IChcbiAgICAgICAgICAgIDx0ZCBvbkNsaWNrPXsgdGhpcy5oYW5kbGVDbGljayB9PlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uUmVuZGVyZXIgPyBzZWxlY3Rpb25SZW5kZXJlcih7XG4gICAgICAgICAgICAgICAgICBtb2RlOiBpbnB1dFR5cGUsXG4gICAgICAgICAgICAgICAgICBjaGVja2VkOiBzZWxlY3RlZCxcbiAgICAgICAgICAgICAgICAgIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgfSkgOiAoXG4gICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgdHlwZT17IGlucHV0VHlwZSB9XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9eyBzZWxlY3RlZCB9XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXsgZGlzYWJsZWQgfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9eyBib290c3RyYXA0ID8gJ3NlbGVjdGlvbi1pbnB1dC00JyA6ICcnIH1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgPC9Cb290c3RyYXBDb250ZXh0LkNvbnN1bWVyPlxuICAgICk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1zZWxlY3Rpb24vc2VsZWN0aW9uLWNlbGwuanMiLCIvKiBlc2xpbnRcbiAgcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzOiAwXG4gIGpzeC1hMTF5L25vLW5vbmludGVyYWN0aXZlLWVsZW1lbnQtaW50ZXJhY3Rpb25zOiAwXG4qL1xuLyogZXNsaW50IG5vLW5lc3RlZC10ZXJuYXJ5OiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXhwYW5kQ2VsbCBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgcm93S2V5OiBQcm9wVHlwZXMuYW55LFxuICAgIGV4cGFuZGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAgIG9uUm93RXhwYW5kOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGV4cGFuZENvbHVtblJlbmRlcmVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICByb3dJbmRleDogUHJvcFR5cGVzLm51bWJlclxuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmhhbmRsZUNsaWNrID0gdGhpcy5oYW5kbGVDbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgaGFuZGxlQ2xpY2soZSkge1xuICAgIGNvbnN0IHsgcm93S2V5LCBleHBhbmRlZCwgb25Sb3dFeHBhbmQsIHJvd0luZGV4IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgb25Sb3dFeHBhbmQocm93S2V5LCBleHBhbmRlZCwgcm93SW5kZXgsIGUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgZXhwYW5kZWQsIGV4cGFuZENvbHVtblJlbmRlcmVyIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDx0ZCBvbkNsaWNrPXsgdGhpcy5oYW5kbGVDbGljayB9PlxuICAgICAgICB7XG4gICAgICAgICAgZXhwYW5kQ29sdW1uUmVuZGVyZXIgPyBleHBhbmRDb2x1bW5SZW5kZXJlcih7XG4gICAgICAgICAgICBleHBhbmRlZFxuICAgICAgICAgIH0pIDogKGV4cGFuZGVkID8gJygtKScgOiAnKCspJylcbiAgICAgICAgfVxuICAgICAgPC90ZD5cbiAgICApO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9yb3ctZXhwYW5kL2V4cGFuZC1jZWxsLmpzIiwiaW1wb3J0IF8gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgQ29uc3QgZnJvbSAnLi9jb25zdCc7XG5cbmNvbnN0IGV2ZW50cyA9IFtcbiAgJ29uQ2xpY2snLFxuICAnb25Eb3VibGVDbGljaycsXG4gICdvbk1vdXNlRW50ZXInLFxuICAnb25Nb3VzZUxlYXZlJ1xuXTtcblxuZXhwb3J0IGRlZmF1bHQgRXh0ZW5kQmFzZSA9PlxuICBjbGFzcyBSb3dFdmVudERlbGVnYXRlciBleHRlbmRzIEV4dGVuZEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICBzdXBlcihwcm9wcyk7XG4gICAgICB0aGlzLmNsaWNrTnVtID0gMDtcbiAgICAgIHRoaXMuY3JlYXRlRGVmYXVsdEV2ZW50SGFuZGxlciA9IHRoaXMuY3JlYXRlRGVmYXVsdEV2ZW50SGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5jcmVhdGVDbGlja0V2ZW50SGFuZGxlciA9IHRoaXMuY3JlYXRlQ2xpY2tFdmVudEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjcmVhdGVEZWZhdWx0RXZlbnRIYW5kbGVyKGNiKSB7XG4gICAgICByZXR1cm4gKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyByb3csIHJvd0luZGV4IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjYihlLCByb3csIHJvd0luZGV4KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xpY2tFdmVudEhhbmRsZXIoY2IpIHtcbiAgICAgIHJldHVybiAoZSkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcm93LFxuICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgIGtleUZpZWxkLFxuICAgICAgICAgIHNlbGVjdGFibGUsXG4gICAgICAgICAgZXhwYW5kYWJsZSxcbiAgICAgICAgICByb3dJbmRleCxcbiAgICAgICAgICBleHBhbmRlZCxcbiAgICAgICAgICBleHBhbmRSb3csXG4gICAgICAgICAgc2VsZWN0Um93LFxuICAgICAgICAgIGNlbGxFZGl0OiB7XG4gICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgREJDTElDS19UT19DRUxMX0VESVQsXG4gICAgICAgICAgICBERUxBWV9GT1JfREJDTElDS1xuICAgICAgICAgIH1cbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgY29uc3QgY2xpY2tGbiA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIGNiKGUsIHJvdywgcm93SW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBrZXkgPSBfLmdldChyb3csIGtleUZpZWxkKTtcbiAgICAgICAgICBpZiAoZXhwYW5kUm93ICYmIGV4cGFuZGFibGUpIHtcbiAgICAgICAgICAgIGV4cGFuZFJvdy5vblJvd0V4cGFuZChrZXksICFleHBhbmRlZCwgcm93SW5kZXgsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VsZWN0Um93Lm1vZGUgIT09IENvbnN0LlJPV19TRUxFQ1RfRElTQUJMRUQgJiYgc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgc2VsZWN0Um93Lm9uUm93U2VsZWN0KGtleSwgIXNlbGVjdGVkLCByb3dJbmRleCwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtb2RlID09PSBEQkNMSUNLX1RPX0NFTExfRURJVCAmJiBzZWxlY3RSb3cuY2xpY2tUb0VkaXQpIHtcbiAgICAgICAgICB0aGlzLmNsaWNrTnVtICs9IDE7XG4gICAgICAgICAgXy5kZWJvdW5jZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGlja051bSA9PT0gMSkge1xuICAgICAgICAgICAgICBjbGlja0ZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsaWNrTnVtID0gMDtcbiAgICAgICAgICB9LCBERUxBWV9GT1JfREJDTElDSykoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGlja0ZuKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVsZWdhdGUoYXR0cnMgPSB7fSkge1xuICAgICAgY29uc3QgbmV3QXR0cnMgPSB7fTtcbiAgICAgIGNvbnN0IHsgZXhwYW5kUm93LCBzZWxlY3RSb3cgfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoZXhwYW5kUm93IHx8IChzZWxlY3RSb3cgJiYgc2VsZWN0Um93LmNsaWNrVG9TZWxlY3QpKSB7XG4gICAgICAgIG5ld0F0dHJzLm9uQ2xpY2sgPSB0aGlzLmNyZWF0ZUNsaWNrRXZlbnRIYW5kbGVyKGF0dHJzLm9uQ2xpY2spO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICAgICAgaWYgKCFuZXdBdHRyc1thdHRyXSkge1xuICAgICAgICAgIGlmIChldmVudHMuaW5jbHVkZXMoYXR0cikpIHtcbiAgICAgICAgICAgIG5ld0F0dHJzW2F0dHJdID0gdGhpcy5jcmVhdGVEZWZhdWx0RXZlbnRIYW5kbGVyKGF0dHJzW2F0dHJdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3QXR0cnNbYXR0cl0gPSBhdHRyc1thdHRyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ld0F0dHJzO1xuICAgIH1cbiAgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1ldmVudC1kZWxlZ2F0ZXIuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY29uc3QgRXhwYW5kUm93ID0gKHsgY2hpbGRyZW4sIC4uLnJlc3QgfSkgPT4gKFxuICA8dHIgY2xhc3NOYW1lPVwiZXhwYW5kaW5nLXJvd1wiPlxuICAgIDx0ZCB7IC4uLnJlc3QgfT57IGNoaWxkcmVuIH08L3RkPlxuICA8L3RyPlxuKTtcblxuRXhwYW5kUm93LnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5FeHBhbmRSb3cuZGVmYXVsdFByb3BzID0ge1xuICBjaGlsZHJlbjogbnVsbFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRXhwYW5kUm93O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LWV4cGFuZC9leHBhbmQtcm93LmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNvbnN0IFJvd1NlY3Rpb24gPSAoeyBjb250ZW50LCBjb2xTcGFuIH0pID0+IChcbiAgPHRyPlxuICAgIDx0ZFxuICAgICAgZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXG4gICAgICBjb2xTcGFuPXsgY29sU3BhbiB9XG4gICAgICBjbGFzc05hbWU9XCJyZWFjdC1icy10YWJsZS1uby1kYXRhXCJcbiAgICA+XG4gICAgICB7IGNvbnRlbnQgfVxuICAgIDwvdGQ+XG4gIDwvdHI+XG4pO1xuXG5Sb3dTZWN0aW9uLnByb3BUeXBlcyA9IHtcbiAgY29udGVudDogUHJvcFR5cGVzLmFueSxcbiAgY29sU3BhbjogUHJvcFR5cGVzLm51bWJlclxufTtcblxuUm93U2VjdGlvbi5kZWZhdWx0UHJvcHMgPSB7XG4gIGNvbnRlbnQ6IG51bGwsXG4gIGNvbFNwYW46IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFJvd1NlY3Rpb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9yb3ctc2VjdGlvbi5qcyIsImltcG9ydCBDb2x1bW5SZXNvbHZlciBmcm9tICcuL2NvbHVtbi1yZXNvbHZlcic7XG5pbXBvcnQgRXhwYW5kUm93UmVzb2x2ZXIgZnJvbSAnLi9leHBhbmQtcm93LXJlc29sdmVyJztcbmltcG9ydCBDb25zdCBmcm9tICcuLi9jb25zdCc7XG5pbXBvcnQgXyBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IEV4dGVuZEJhc2UgPT5cbiAgY2xhc3MgVGFibGVSZXNvbHZlciBleHRlbmRzXG4gICAgRXhwYW5kUm93UmVzb2x2ZXIoQ29sdW1uUmVzb2x2ZXIoRXh0ZW5kQmFzZSkpIHtcbiAgICB2YWxpZGF0ZVByb3BzKCkge1xuICAgICAgY29uc3QgeyBrZXlGaWVsZCB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmICgha2V5RmllbGQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc3BlY2lmeSBhIGZpZWxkIGFzIGtleSB2aWEga2V5RmllbGQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnZpc2libGVDb2x1bW5TaXplKGZhbHNlKSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmlzaWJsZSBjb2x1bW5zIGRldGVjdGVkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmRhdGEubGVuZ3RoID09PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByb3BzIHJlc29sdmVyIGZvciBjZWxsIHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gYWRkdGlvbmFsIG9wdGlvbnMgbGlrZSBjYWxsYmFjayB3aGljaCBhcmUgYWJvdXQgdG8gbWVyZ2UgaW50byBwcm9wc1xuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gcmVzdWx0IC0gcHJvcHMgZm9yIGNlbGwgc2VsZWN0aW9uc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdC5tb2RlIC0gaW5wdXQgdHlwZSBvZiByb3cgc2VsZWN0aW9uIG9yIGRpc2FibGVkLlxuICAgICAqL1xuICAgIHJlc29sdmVTZWxlY3RSb3dQcm9wcyhvcHRpb25zKSB7XG4gICAgICBjb25zdCB7IHNlbGVjdFJvdyB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHsgUk9XX1NFTEVDVF9ESVNBQkxFRCB9ID0gQ29uc3Q7XG5cbiAgICAgIGlmIChfLmlzRGVmaW5lZChzZWxlY3RSb3cpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc2VsZWN0Um93LFxuICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kZTogUk9XX1NFTEVDVF9ESVNBQkxFRFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcm9wcyByZXNvbHZlciBmb3IgaGVhZGVyIGNlbGwgc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBhZGR0aW9uYWwgb3B0aW9ucyBsaWtlIGNhbGxiYWNrIHdoaWNoIGFyZSBhYm91dCB0byBtZXJnZSBpbnRvIHByb3BzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZXN1bHQgLSBwcm9wcyBmb3IgY2VsbCBzZWxlY3Rpb25zXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcmVzdWx0Lm1vZGUgLSBpbnB1dCB0eXBlIG9mIHJvdyBzZWxlY3Rpb24gb3IgZGlzYWJsZWQuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcmVzdWx0LmNoZWNrZWRTdGF0dXMgLSBjaGVja2JveCBzdGF0dXMgZGVwZW5kaW5nIG9uIHNlbGVjdGVkIHJvd3MgY291bnRzXG4gICAgICovXG4gICAgcmVzb2x2ZVNlbGVjdFJvd1Byb3BzRm9ySGVhZGVyKG9wdGlvbnMgPSB7fSkge1xuICAgICAgY29uc3QgeyBzZWxlY3RSb3cgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7IGFsbFJvd3NTZWxlY3RlZCwgYWxsUm93c05vdFNlbGVjdGVkLCAuLi5yZXN0IH0gPSBvcHRpb25zO1xuICAgICAgY29uc3Qge1xuICAgICAgICBST1dfU0VMRUNUX0RJU0FCTEVELCBDSEVDS0JPWF9TVEFUVVNfQ0hFQ0tFRCxcbiAgICAgICAgQ0hFQ0tCT1hfU1RBVFVTX0lOREVURVJNSU5BVEUsIENIRUNLQk9YX1NUQVRVU19VTkNIRUNLRURcbiAgICAgIH0gPSBDb25zdDtcblxuICAgICAgaWYgKF8uaXNEZWZpbmVkKHNlbGVjdFJvdykpIHtcbiAgICAgICAgbGV0IGNoZWNrZWRTdGF0dXM7XG5cbiAgICAgICAgLy8gY2hlY2tib3ggc3RhdHVzIGRlcGVuZGluZyBvbiBzZWxlY3RlZCByb3dzIGNvdW50c1xuICAgICAgICBpZiAoYWxsUm93c1NlbGVjdGVkKSBjaGVja2VkU3RhdHVzID0gQ0hFQ0tCT1hfU1RBVFVTX0NIRUNLRUQ7XG4gICAgICAgIGVsc2UgaWYgKGFsbFJvd3NOb3RTZWxlY3RlZCkgY2hlY2tlZFN0YXR1cyA9IENIRUNLQk9YX1NUQVRVU19VTkNIRUNLRUQ7XG4gICAgICAgIGVsc2UgY2hlY2tlZFN0YXR1cyA9IENIRUNLQk9YX1NUQVRVU19JTkRFVEVSTUlOQVRFO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc2VsZWN0Um93LFxuICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgY2hlY2tlZFN0YXR1c1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RlOiBST1dfU0VMRUNUX0RJU0FCTEVEXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Byb3BzLXJlc29sdmVyL2luZGV4LmpzIiwiZXhwb3J0IGRlZmF1bHQgRXh0ZW5kQmFzZSA9PlxuICBjbGFzcyBDb2x1bW5SZXNvbHZlciBleHRlbmRzIEV4dGVuZEJhc2Uge1xuICAgIHZpc2libGVDb2x1bW5TaXplKGluY2x1ZGVTZWxlY3RDb2x1bW4gPSB0cnVlKSB7XG4gICAgICBsZXQgY29sdW1uTGVuID0gdGhpcy5wcm9wcy5jb2x1bW5zLmZpbHRlcihjID0+ICFjLmhpZGRlbikubGVuZ3RoO1xuICAgICAgaWYgKCFpbmNsdWRlU2VsZWN0Q29sdW1uKSByZXR1cm4gY29sdW1uTGVuO1xuICAgICAgaWYgKHRoaXMucHJvcHMuc2VsZWN0Um93ICYmICF0aGlzLnByb3BzLnNlbGVjdFJvdy5oaWRlU2VsZWN0Q29sdW1uKSB7XG4gICAgICAgIGNvbHVtbkxlbiArPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJvcHMuZXhwYW5kUm93ICYmIHRoaXMucHJvcHMuZXhwYW5kUm93LnNob3dFeHBhbmRDb2x1bW4pIHtcbiAgICAgICAgY29sdW1uTGVuICs9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sdW1uTGVuO1xuICAgIH1cbiAgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Byb3BzLXJlc29sdmVyL2NvbHVtbi1yZXNvbHZlci5qcyIsImV4cG9ydCBkZWZhdWx0IEV4dGVuZEJhc2UgPT5cbiAgY2xhc3MgRXhwYW5kUm93UmVzb2x2ZXIgZXh0ZW5kcyBFeHRlbmRCYXNlIHtcbiAgICByZXNvbHZlRXhwYW5kUm93UHJvcHMoKSB7XG4gICAgICBjb25zdCB7IGV4cGFuZFJvdywgZXhwYW5kZWQsIG9uUm93RXhwYW5kLCBvbkFsbFJvd0V4cGFuZCwgaXNBbnlFeHBhbmRzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKGV4cGFuZFJvdykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmV4cGFuZFJvdyxcbiAgICAgICAgICBleHBhbmRlZCxcbiAgICAgICAgICBvblJvd0V4cGFuZCxcbiAgICAgICAgICBvbkFsbFJvd0V4cGFuZCxcbiAgICAgICAgICBpc0FueUV4cGFuZHMsXG4gICAgICAgICAgbm9uRXhwYW5kYWJsZTogZXhwYW5kUm93Lm5vbkV4cGFuZGFibGUgfHwgW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Byb3BzLXJlc29sdmVyL2V4cGFuZC1yb3ctcmVzb2x2ZXIuanMiLCIvKiBlc2xpbnQgbm8tcmV0dXJuLWFzc2lnbjogMCAqL1xuLyogZXNsaW50IGNsYXNzLW1ldGhvZHMtdXNlLXRoaXM6IDAgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgXyBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgY3JlYXRlRGF0YUNvbnRleHQgZnJvbSAnLi9kYXRhLWNvbnRleHQnO1xuaW1wb3J0IGNyZWF0ZVNvcnRDb250ZXh0IGZyb20gJy4vc29ydC1jb250ZXh0JztcbmltcG9ydCBjcmVhdGVTZWxlY3Rpb25Db250ZXh0IGZyb20gJy4vc2VsZWN0aW9uLWNvbnRleHQnO1xuaW1wb3J0IGNyZWF0ZVJvd0V4cGFuZENvbnRleHQgZnJvbSAnLi9yb3ctZXhwYW5kLWNvbnRleHQnO1xuaW1wb3J0IHJlbW90ZVJlc29sdmVyIGZyb20gJy4uL3Byb3BzLXJlc29sdmVyL3JlbW90ZS1yZXNvbHZlcic7XG5pbXBvcnQgeyBCb290c3RyYXBDb250ZXh0IH0gZnJvbSAnLi9ib290c3RyYXAnO1xuaW1wb3J0IGRhdGFPcGVyYXRvciBmcm9tICcuLi9zdG9yZS9vcGVyYXRvcnMnO1xuXG5jb25zdCB3aXRoQ29udGV4dCA9IEJhc2UgPT5cbiAgY2xhc3MgQm9vdHN0cmFwVGFibGVDb250YWluZXIgZXh0ZW5kcyByZW1vdGVSZXNvbHZlcihDb21wb25lbnQpIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgdGhpcy5EYXRhQ29udGV4dCA9IGNyZWF0ZURhdGFDb250ZXh0KCk7XG5cbiAgICAgIGlmIChwcm9wcy5jb2x1bW5zLmZpbHRlcihjb2wgPT4gY29sLnNvcnQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5Tb3J0Q29udGV4dCA9IGNyZWF0ZVNvcnRDb250ZXh0KFxuICAgICAgICAgIGRhdGFPcGVyYXRvciwgdGhpcy5pc1JlbW90ZVNvcnQsIHRoaXMuaGFuZGxlUmVtb3RlU29ydENoYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5zZWxlY3RSb3cpIHtcbiAgICAgICAgdGhpcy5TZWxlY3Rpb25Db250ZXh0ID0gY3JlYXRlU2VsZWN0aW9uQ29udGV4dChkYXRhT3BlcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMuZXhwYW5kUm93KSB7XG4gICAgICAgIHRoaXMuUm93RXhwYW5kQ29udGV4dCA9IGNyZWF0ZVJvd0V4cGFuZENvbnRleHQoZGF0YU9wZXJhdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLmNlbGxFZGl0ICYmIHByb3BzLmNlbGxFZGl0LmNyZWF0ZUNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5DZWxsRWRpdENvbnRleHQgPSBwcm9wcy5jZWxsRWRpdC5jcmVhdGVDb250ZXh0KFxuICAgICAgICAgIF8sIGRhdGFPcGVyYXRvciwgdGhpcy5pc1JlbW90ZUNlbGxFZGl0LCB0aGlzLmhhbmRsZVJlbW90ZUNlbGxDaGFuZ2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMuZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuRmlsdGVyQ29udGV4dCA9IHByb3BzLmZpbHRlci5jcmVhdGVDb250ZXh0KFxuICAgICAgICAgIF8sIHRoaXMuaXNSZW1vdGVGaWx0ZXJpbmcsIHRoaXMuaGFuZGxlUmVtb3RlRmlsdGVyQ2hhbmdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLnBhZ2luYXRpb24pIHtcbiAgICAgICAgdGhpcy5QYWdpbmF0aW9uQ29udGV4dCA9IHByb3BzLnBhZ2luYXRpb24uY3JlYXRlQ29udGV4dChcbiAgICAgICAgICB0aGlzLmlzUmVtb3RlUGFnaW5hdGlvbiwgdGhpcy5oYW5kbGVSZW1vdGVQYWdlQ2hhbmdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLnNlYXJjaCAmJiBwcm9wcy5zZWFyY2guc2VhcmNoQ29udGV4dCkge1xuICAgICAgICB0aGlzLlNlYXJjaENvbnRleHQgPSBwcm9wcy5zZWFyY2guc2VhcmNoQ29udGV4dChcbiAgICAgICAgICBfLCB0aGlzLmlzUmVtb3RlU2VhcmNoLCB0aGlzLmhhbmRsZVJlbW90ZVNlYXJjaENoYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5zZXREZXBlbmRlbmN5TW9kdWxlcykge1xuICAgICAgICBwcm9wcy5zZXREZXBlbmRlbmN5TW9kdWxlcyhfKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXJCYXNlKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgcm9vdFByb3BzLFxuICAgICAgICBjZWxsRWRpdFByb3BzLFxuICAgICAgICBmaWx0ZXJQcm9wcyxcbiAgICAgICAgc2VhcmNoUHJvcHMsXG4gICAgICAgIHNvcnRQcm9wcyxcbiAgICAgICAgcGFnaW5hdGlvblByb3BzLFxuICAgICAgICBleHBhbmRQcm9wcyxcbiAgICAgICAgc2VsZWN0aW9uUHJvcHNcbiAgICAgICkgPT4gKFxuICAgICAgICA8QmFzZVxuICAgICAgICAgIHsgLi4udGhpcy5wcm9wcyB9XG4gICAgICAgICAgeyAuLi5zZWxlY3Rpb25Qcm9wcyB9XG4gICAgICAgICAgeyAuLi5zb3J0UHJvcHMgfVxuICAgICAgICAgIHsgLi4uY2VsbEVkaXRQcm9wcyB9XG4gICAgICAgICAgeyAuLi5maWx0ZXJQcm9wcyB9XG4gICAgICAgICAgeyAuLi5zZWFyY2hQcm9wcyB9XG4gICAgICAgICAgeyAuLi5wYWdpbmF0aW9uUHJvcHMgfVxuICAgICAgICAgIHsgLi4uZXhwYW5kUHJvcHMgfVxuICAgICAgICAgIGRhdGE9eyByb290UHJvcHMuZ2V0RGF0YShmaWx0ZXJQcm9wcywgc2VhcmNoUHJvcHMsIHNvcnRQcm9wcywgcGFnaW5hdGlvblByb3BzKSB9XG4gICAgICAgIC8+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlcldpdGhTZWxlY3Rpb25DdHgoYmFzZSwgYmFzZVByb3BzKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICByb290UHJvcHMsXG4gICAgICAgIGNlbGxFZGl0UHJvcHMsXG4gICAgICAgIGZpbHRlclByb3BzLFxuICAgICAgICBzZWFyY2hQcm9wcyxcbiAgICAgICAgc29ydFByb3BzLFxuICAgICAgICBwYWdpbmF0aW9uUHJvcHMsXG4gICAgICAgIGV4cGFuZFByb3BzXG4gICAgICApID0+IChcbiAgICAgICAgPHRoaXMuU2VsZWN0aW9uQ29udGV4dC5Qcm92aWRlclxuICAgICAgICAgIHsgLi4uYmFzZVByb3BzIH1cbiAgICAgICAgICBzZWxlY3RSb3c9eyB0aGlzLnByb3BzLnNlbGVjdFJvdyB9XG4gICAgICAgICAgZGF0YT17IHJvb3RQcm9wcy5nZXREYXRhKGZpbHRlclByb3BzLCBzZWFyY2hQcm9wcywgc29ydFByb3BzLCBwYWdpbmF0aW9uUHJvcHMpIH1cbiAgICAgICAgPlxuICAgICAgICAgIDx0aGlzLlNlbGVjdGlvbkNvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvblByb3BzID0+IGJhc2UoXG4gICAgICAgICAgICAgICAgcm9vdFByb3BzLFxuICAgICAgICAgICAgICAgIGNlbGxFZGl0UHJvcHMsXG4gICAgICAgICAgICAgICAgZmlsdGVyUHJvcHMsXG4gICAgICAgICAgICAgICAgc2VhcmNoUHJvcHMsXG4gICAgICAgICAgICAgICAgc29ydFByb3BzLFxuICAgICAgICAgICAgICAgIHBhZ2luYXRpb25Qcm9wcyxcbiAgICAgICAgICAgICAgICBleHBhbmRQcm9wcyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Qcm9wc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgPC90aGlzLlNlbGVjdGlvbkNvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgIDwvdGhpcy5TZWxlY3Rpb25Db250ZXh0LlByb3ZpZGVyPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXJXaXRoUm93RXhwYW5kQ3R4KGJhc2UsIGJhc2VQcm9wcykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgcm9vdFByb3BzLFxuICAgICAgICBjZWxsRWRpdFByb3BzLFxuICAgICAgICBmaWx0ZXJQcm9wcyxcbiAgICAgICAgc2VhcmNoUHJvcHMsXG4gICAgICAgIHNvcnRQcm9wcyxcbiAgICAgICAgcGFnaW5hdGlvblByb3BzXG4gICAgICApID0+IChcbiAgICAgICAgPHRoaXMuUm93RXhwYW5kQ29udGV4dC5Qcm92aWRlclxuICAgICAgICAgIHsgLi4uYmFzZVByb3BzIH1cbiAgICAgICAgICBleHBhbmRSb3c9eyB0aGlzLnByb3BzLmV4cGFuZFJvdyB9XG4gICAgICAgICAgZGF0YT17IHJvb3RQcm9wcy5nZXREYXRhKGZpbHRlclByb3BzLCBzZWFyY2hQcm9wcywgc29ydFByb3BzLCBwYWdpbmF0aW9uUHJvcHMpIH1cbiAgICAgICAgPlxuICAgICAgICAgIDx0aGlzLlJvd0V4cGFuZENvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGV4cGFuZFByb3BzID0+IGJhc2UoXG4gICAgICAgICAgICAgICAgcm9vdFByb3BzLFxuICAgICAgICAgICAgICAgIGNlbGxFZGl0UHJvcHMsXG4gICAgICAgICAgICAgICAgZmlsdGVyUHJvcHMsXG4gICAgICAgICAgICAgICAgc2VhcmNoUHJvcHMsXG4gICAgICAgICAgICAgICAgc29ydFByb3BzLFxuICAgICAgICAgICAgICAgIHBhZ2luYXRpb25Qcm9wcyxcbiAgICAgICAgICAgICAgICBleHBhbmRQcm9wc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgPC90aGlzLlJvd0V4cGFuZENvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgIDwvdGhpcy5Sb3dFeHBhbmRDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXJXaXRoUGFnaW5hdGlvbkN0eChiYXNlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICByb290UHJvcHMsXG4gICAgICAgIGNlbGxFZGl0UHJvcHMsXG4gICAgICAgIGZpbHRlclByb3BzLFxuICAgICAgICBzZWFyY2hQcm9wcyxcbiAgICAgICAgc29ydFByb3BzXG4gICAgICApID0+IChcbiAgICAgICAgPHRoaXMuUGFnaW5hdGlvbkNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgICByZWY9eyBuID0+IHRoaXMucGFnaW5hdGlvbkNvbnRleHQgPSBuIH1cbiAgICAgICAgICBwYWdpbmF0aW9uPXsgdGhpcy5wcm9wcy5wYWdpbmF0aW9uIH1cbiAgICAgICAgICBkYXRhPXsgcm9vdFByb3BzLmdldERhdGEoZmlsdGVyUHJvcHMsIHNlYXJjaFByb3BzLCBzb3J0UHJvcHMpIH1cbiAgICAgICAgICBib290c3RyYXA0PXsgdGhpcy5wcm9wcy5ib290c3RyYXA0IH1cbiAgICAgICAgPlxuICAgICAgICAgIDx0aGlzLlBhZ2luYXRpb25Db250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwYWdpbmF0aW9uUHJvcHMgPT4gYmFzZShcbiAgICAgICAgICAgICAgICByb290UHJvcHMsXG4gICAgICAgICAgICAgICAgY2VsbEVkaXRQcm9wcyxcbiAgICAgICAgICAgICAgICBmaWx0ZXJQcm9wcyxcbiAgICAgICAgICAgICAgICBzZWFyY2hQcm9wcyxcbiAgICAgICAgICAgICAgICBzb3J0UHJvcHMsXG4gICAgICAgICAgICAgICAgcGFnaW5hdGlvblByb3BzXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L3RoaXMuUGFnaW5hdGlvbkNvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgIDwvdGhpcy5QYWdpbmF0aW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyV2l0aFNvcnRDdHgoYmFzZSwgYmFzZVByb3BzKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICByb290UHJvcHMsXG4gICAgICAgIGNlbGxFZGl0UHJvcHMsXG4gICAgICAgIGZpbHRlclByb3BzLFxuICAgICAgICBzZWFyY2hQcm9wc1xuICAgICAgKSA9PiAoXG4gICAgICAgIDx0aGlzLlNvcnRDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgeyAuLi5iYXNlUHJvcHMgfVxuICAgICAgICAgIHJlZj17IG4gPT4gdGhpcy5zb3J0Q29udGV4dCA9IG4gfVxuICAgICAgICAgIGRlZmF1bHRTb3J0ZWQ9eyB0aGlzLnByb3BzLmRlZmF1bHRTb3J0ZWQgfVxuICAgICAgICAgIGRlZmF1bHRTb3J0RGlyZWN0aW9uPXsgdGhpcy5wcm9wcy5kZWZhdWx0U29ydERpcmVjdGlvbiB9XG4gICAgICAgICAgZGF0YT17IHJvb3RQcm9wcy5nZXREYXRhKGZpbHRlclByb3BzLCBzZWFyY2hQcm9wcykgfVxuICAgICAgICA+XG4gICAgICAgICAgPHRoaXMuU29ydENvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNvcnRQcm9wcyA9PiBiYXNlKFxuICAgICAgICAgICAgICAgIHJvb3RQcm9wcyxcbiAgICAgICAgICAgICAgICBjZWxsRWRpdFByb3BzLFxuICAgICAgICAgICAgICAgIGZpbHRlclByb3BzLFxuICAgICAgICAgICAgICAgIHNlYXJjaFByb3BzLFxuICAgICAgICAgICAgICAgIHNvcnRQcm9wcyxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvdGhpcy5Tb3J0Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgPC90aGlzLlNvcnRDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXJXaXRoU2VhcmNoQ3R4KGJhc2UsIGJhc2VQcm9wcykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgcm9vdFByb3BzLFxuICAgICAgICBjZWxsRWRpdFByb3BzLFxuICAgICAgICBmaWx0ZXJQcm9wc1xuICAgICAgKSA9PiAoXG4gICAgICAgIDx0aGlzLlNlYXJjaENvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgICB7IC4uLmJhc2VQcm9wcyB9XG4gICAgICAgICAgcmVmPXsgbiA9PiB0aGlzLnNlYXJjaENvbnRleHQgPSBuIH1cbiAgICAgICAgICBkYXRhPXsgcm9vdFByb3BzLmdldERhdGEoZmlsdGVyUHJvcHMpIH1cbiAgICAgICAgICBzZWFyY2hUZXh0PXsgdGhpcy5wcm9wcy5zZWFyY2guc2VhcmNoVGV4dCB9XG4gICAgICAgID5cbiAgICAgICAgICA8dGhpcy5TZWFyY2hDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzZWFyY2hQcm9wcyA9PiBiYXNlKFxuICAgICAgICAgICAgICAgIHJvb3RQcm9wcyxcbiAgICAgICAgICAgICAgICBjZWxsRWRpdFByb3BzLFxuICAgICAgICAgICAgICAgIGZpbHRlclByb3BzLFxuICAgICAgICAgICAgICAgIHNlYXJjaFByb3BzXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L3RoaXMuU2VhcmNoQ29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgPC90aGlzLlNlYXJjaENvbnRleHQuUHJvdmlkZXI+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlcldpdGhGaWx0ZXJDdHgoYmFzZSwgYmFzZVByb3BzKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICByb290UHJvcHMsXG4gICAgICAgIGNlbGxFZGl0UHJvcHNcbiAgICAgICkgPT4gKFxuICAgICAgICA8dGhpcy5GaWx0ZXJDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgeyAuLi5iYXNlUHJvcHMgfVxuICAgICAgICAgIHJlZj17IG4gPT4gdGhpcy5maWx0ZXJDb250ZXh0ID0gbiB9XG4gICAgICAgICAgZGF0YT17IHJvb3RQcm9wcy5nZXREYXRhKCkgfVxuICAgICAgICA+XG4gICAgICAgICAgPHRoaXMuRmlsdGVyQ29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZmlsdGVyUHJvcHMgPT4gYmFzZShcbiAgICAgICAgICAgICAgICByb290UHJvcHMsXG4gICAgICAgICAgICAgICAgY2VsbEVkaXRQcm9wcyxcbiAgICAgICAgICAgICAgICBmaWx0ZXJQcm9wc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgPC90aGlzLkZpbHRlckNvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgIDwvdGhpcy5GaWx0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXJXaXRoQ2VsbEVkaXRDdHgoYmFzZSwgYmFzZVByb3BzKSB7XG4gICAgICByZXR1cm4gcm9vdFByb3BzID0+IChcbiAgICAgICAgPHRoaXMuQ2VsbEVkaXRDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgeyAuLi5iYXNlUHJvcHMgfVxuICAgICAgICAgIHNlbGVjdFJvdz17IHRoaXMucHJvcHMuc2VsZWN0Um93IH1cbiAgICAgICAgICBjZWxsRWRpdD17IHRoaXMucHJvcHMuY2VsbEVkaXQgfVxuICAgICAgICAgIGRhdGE9eyByb290UHJvcHMuZ2V0RGF0YSgpIH1cbiAgICAgICAgPlxuICAgICAgICAgIDx0aGlzLkNlbGxFZGl0Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2VsbEVkaXRQcm9wcyA9PiBiYXNlKHJvb3RQcm9wcywgY2VsbEVkaXRQcm9wcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L3RoaXMuQ2VsbEVkaXRDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICA8L3RoaXMuQ2VsbEVkaXRDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICBjb25zdCB7IGtleUZpZWxkLCBjb2x1bW5zLCBib290c3RyYXA0IH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgYmFzZVByb3BzID0geyBrZXlGaWVsZCwgY29sdW1ucyB9O1xuXG4gICAgICBsZXQgYmFzZSA9IHRoaXMucmVuZGVyQmFzZSgpO1xuXG4gICAgICBpZiAodGhpcy5TZWxlY3Rpb25Db250ZXh0KSB7XG4gICAgICAgIGJhc2UgPSB0aGlzLnJlbmRlcldpdGhTZWxlY3Rpb25DdHgoYmFzZSwgYmFzZVByb3BzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuUm93RXhwYW5kQ29udGV4dCkge1xuICAgICAgICBiYXNlID0gdGhpcy5yZW5kZXJXaXRoUm93RXhwYW5kQ3R4KGJhc2UsIGJhc2VQcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLlBhZ2luYXRpb25Db250ZXh0KSB7XG4gICAgICAgIGJhc2UgPSB0aGlzLnJlbmRlcldpdGhQYWdpbmF0aW9uQ3R4KGJhc2UsIGJhc2VQcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLlNvcnRDb250ZXh0KSB7XG4gICAgICAgIGJhc2UgPSB0aGlzLnJlbmRlcldpdGhTb3J0Q3R4KGJhc2UsIGJhc2VQcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLlNlYXJjaENvbnRleHQpIHtcbiAgICAgICAgYmFzZSA9IHRoaXMucmVuZGVyV2l0aFNlYXJjaEN0eChiYXNlLCBiYXNlUHJvcHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5GaWx0ZXJDb250ZXh0KSB7XG4gICAgICAgIGJhc2UgPSB0aGlzLnJlbmRlcldpdGhGaWx0ZXJDdHgoYmFzZSwgYmFzZVByb3BzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuQ2VsbEVkaXRDb250ZXh0KSB7XG4gICAgICAgIGJhc2UgPSB0aGlzLnJlbmRlcldpdGhDZWxsRWRpdEN0eChiYXNlLCBiYXNlUHJvcHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Qm9vdHN0cmFwQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17IHsgYm9vdHN0cmFwNCB9IH0+XG4gICAgICAgICAgPHRoaXMuRGF0YUNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgICAgIHsgLi4uYmFzZVByb3BzIH1cbiAgICAgICAgICAgIGRhdGE9eyB0aGlzLnByb3BzLmRhdGEgfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDx0aGlzLkRhdGFDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmFzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA8L3RoaXMuRGF0YUNvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgICAgPC90aGlzLkRhdGFDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICA8L0Jvb3RzdHJhcENvbnRleHQuUHJvdmlkZXI+XG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aENvbnRleHQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb250ZXh0cy9pbmRleC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCAoKSA9PiB7XG4gIGNvbnN0IERhdGFDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCgpO1xuXG4gIGNsYXNzIERhdGFQcm92aWRlciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgIGRhdGE6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLmlzUmVxdWlyZWRcbiAgICB9XG5cbiAgICBzdGF0ZSA9IHsgZGF0YTogdGhpcy5wcm9wcy5kYXRhIH07XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyBkYXRhOiBuZXh0UHJvcHMuZGF0YSB9KSk7XG4gICAgfVxuXG4gICAgZ2V0RGF0YSA9IChmaWx0ZXJQcm9wcywgc2VhcmNoUHJvcHMsIHNvcnRQcm9wcywgcGFnaW5hdGlvblByb3BzKSA9PiB7XG4gICAgICBpZiAocGFnaW5hdGlvblByb3BzKSByZXR1cm4gcGFnaW5hdGlvblByb3BzLmRhdGE7XG4gICAgICBlbHNlIGlmIChzb3J0UHJvcHMpIHJldHVybiBzb3J0UHJvcHMuZGF0YTtcbiAgICAgIGVsc2UgaWYgKHNlYXJjaFByb3BzKSByZXR1cm4gc2VhcmNoUHJvcHMuZGF0YTtcbiAgICAgIGVsc2UgaWYgKGZpbHRlclByb3BzKSByZXR1cm4gZmlsdGVyUHJvcHMuZGF0YTtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmRhdGE7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPERhdGFDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgdmFsdWU9eyB7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLnN0YXRlLmRhdGEsXG4gICAgICAgICAgICBnZXREYXRhOiB0aGlzLmdldERhdGFcbiAgICAgICAgICB9IH1cbiAgICAgICAgPlxuICAgICAgICAgIHsgdGhpcy5wcm9wcy5jaGlsZHJlbiB9XG4gICAgICAgIDwvRGF0YUNvbnRleHQuUHJvdmlkZXI+XG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIFByb3ZpZGVyOiBEYXRhUHJvdmlkZXIsXG4gICAgQ29uc3VtZXI6IERhdGFDb250ZXh0LkNvbnN1bWVyXG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvY29udGV4dHMvZGF0YS1jb250ZXh0LmpzIiwiLyogZXNsaW50IHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wczogMCAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ29uc3QgZnJvbSAnLi4vY29uc3QnO1xuXG5leHBvcnQgZGVmYXVsdCAoXG4gIGRhdGFPcGVyYXRvcixcbiAgaXNSZW1vdGVTb3J0LFxuICBoYW5kbGVTb3J0Q2hhbmdlXG4pID0+IHtcbiAgY29uc3QgU29ydENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KCk7XG5cbiAgY2xhc3MgU29ydFByb3ZpZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gICAgICBjb2x1bW5zOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuICAgICAgZGVmYXVsdFNvcnRlZDogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgICAgZGF0YUZpZWxkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgICAgIG9yZGVyOiBQcm9wVHlwZXMub25lT2YoW0NvbnN0LlNPUlRfREVTQywgQ29uc3QuU09SVF9BU0NdKS5pc1JlcXVpcmVkXG4gICAgICB9KSksXG4gICAgICBkZWZhdWx0U29ydERpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFtDb25zdC5TT1JUX0RFU0MsIENvbnN0LlNPUlRfQVNDXSlcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgbGV0IHNvcnRPcmRlcjtcbiAgICAgIGxldCBzb3J0Q29sdW1uO1xuICAgICAgY29uc3QgeyBjb2x1bW5zLCBkZWZhdWx0U29ydGVkLCBkZWZhdWx0U29ydERpcmVjdGlvbiB9ID0gcHJvcHM7XG5cbiAgICAgIGlmIChkZWZhdWx0U29ydGVkICYmIGRlZmF1bHRTb3J0ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBzb3J0RmllbGQgPSBkZWZhdWx0U29ydGVkWzBdLmRhdGFGaWVsZDtcbiAgICAgICAgc29ydE9yZGVyID0gZGVmYXVsdFNvcnRlZFswXS5vcmRlciB8fCBkZWZhdWx0U29ydERpcmVjdGlvbjtcbiAgICAgICAgY29uc3Qgc29ydENvbHVtbnMgPSBjb2x1bW5zLmZpbHRlcihjb2wgPT4gY29sLmRhdGFGaWVsZCA9PT0gc29ydEZpZWxkKTtcbiAgICAgICAgaWYgKHNvcnRDb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzb3J0Q29sdW1uID0gc29ydENvbHVtbnNbMF07XG5cbiAgICAgICAgICBpZiAoc29ydENvbHVtbi5vblNvcnQpIHtcbiAgICAgICAgICAgIHNvcnRDb2x1bW4ub25Tb3J0KHNvcnRGaWVsZCwgc29ydE9yZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSB7IHNvcnRPcmRlciwgc29ydENvbHVtbiB9O1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgY29uc3QgeyBzb3J0T3JkZXIsIHNvcnRDb2x1bW4gfSA9IHRoaXMuc3RhdGU7XG4gICAgICBpZiAoaXNSZW1vdGVTb3J0KCkgJiYgc29ydE9yZGVyICYmIHNvcnRDb2x1bW4pIHtcbiAgICAgICAgaGFuZGxlU29ydENoYW5nZShzb3J0Q29sdW1uLmRhdGFGaWVsZCwgc29ydE9yZGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVTb3J0ID0gKGNvbHVtbikgPT4ge1xuICAgICAgY29uc3Qgc29ydE9yZGVyID0gZGF0YU9wZXJhdG9yLm5leHRPcmRlcihjb2x1bW4sIHRoaXMuc3RhdGUsIHRoaXMucHJvcHMuZGVmYXVsdFNvcnREaXJlY3Rpb24pO1xuXG4gICAgICBpZiAoY29sdW1uLm9uU29ydCkge1xuICAgICAgICBjb2x1bW4ub25Tb3J0KGNvbHVtbi5kYXRhRmllbGQsIHNvcnRPcmRlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1JlbW90ZVNvcnQoKSkge1xuICAgICAgICBoYW5kbGVTb3J0Q2hhbmdlKGNvbHVtbi5kYXRhRmllbGQsIHNvcnRPcmRlcik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7XG4gICAgICAgIHNvcnRPcmRlcixcbiAgICAgICAgc29ydENvbHVtbjogY29sdW1uXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgbGV0IHsgZGF0YSB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHsgc29ydE9yZGVyLCBzb3J0Q29sdW1uIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgaWYgKCFpc1JlbW90ZVNvcnQoKSAmJiBzb3J0Q29sdW1uKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhT3BlcmF0b3Iuc29ydChkYXRhLCBzb3J0T3JkZXIsIHNvcnRDb2x1bW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8U29ydENvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgICB2YWx1ZT17IHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBzb3J0T3JkZXIsXG4gICAgICAgICAgICBvblNvcnQ6IHRoaXMuaGFuZGxlU29ydCxcbiAgICAgICAgICAgIHNvcnRGaWVsZDogc29ydENvbHVtbiA/IHNvcnRDb2x1bW4uZGF0YUZpZWxkIDogbnVsbFxuICAgICAgICAgIH0gfVxuICAgICAgICA+XG4gICAgICAgICAgeyB0aGlzLnByb3BzLmNoaWxkcmVuIH1cbiAgICAgICAgPC9Tb3J0Q29udGV4dC5Qcm92aWRlcj5cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgUHJvdmlkZXI6IFNvcnRQcm92aWRlcixcbiAgICBDb25zdW1lcjogU29ydENvbnRleHQuQ29uc3VtZXJcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb250ZXh0cy9zb3J0LWNvbnRleHQuanMiLCIvKiBlc2xpbnQgcmVhY3QvcHJvcC10eXBlczogMCAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ29uc3QgZnJvbSAnLi4vY29uc3QnO1xuXG5leHBvcnQgZGVmYXVsdCAoXG4gIGRhdGFPcGVyYXRvclxuKSA9PiB7XG4gIGNvbnN0IFNlbGVjdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KCk7XG5cbiAgY2xhc3MgU2VsZWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcbiAgICAgIGRhdGE6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICAgICAga2V5RmllbGQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZFxuICAgIH1cblxuICAgIHN0YXRlID0geyBzZWxlY3RlZDogKHRoaXMucHJvcHMuc2VsZWN0Um93ICYmIHRoaXMucHJvcHMuc2VsZWN0Um93LnNlbGVjdGVkKSB8fCBbXSB9O1xuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMuc2VsZWN0Um93KSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHtcbiAgICAgICAgICBzZWxlY3RlZDogbmV4dFByb3BzLnNlbGVjdFJvdy5zZWxlY3RlZCB8fCB0aGlzLnN0YXRlLnNlbGVjdGVkXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVSb3dTZWxlY3QgPSAocm93S2V5LCBjaGVja2VkLCByb3dJbmRleCwgZSkgPT4ge1xuICAgICAgY29uc3QgeyBkYXRhLCBrZXlGaWVsZCwgc2VsZWN0Um93OiB7IG1vZGUsIG9uU2VsZWN0IH0gfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7IFJPV19TRUxFQ1RfU0lOR0xFIH0gPSBDb25zdDtcblxuICAgICAgbGV0IGN1cnJTZWxlY3RlZCA9IFsuLi50aGlzLnN0YXRlLnNlbGVjdGVkXTtcblxuICAgICAgaWYgKG1vZGUgPT09IFJPV19TRUxFQ1RfU0lOR0xFKSB7IC8vIHdoZW4gc2VsZWN0IG1vZGUgaXMgcmFkaW9cbiAgICAgICAgY3VyclNlbGVjdGVkID0gW3Jvd0tleV07XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrZWQpIHsgLy8gd2hlbiBzZWxlY3QgbW9kZSBpcyBjaGVja2JveFxuICAgICAgICBjdXJyU2VsZWN0ZWQucHVzaChyb3dLZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VyclNlbGVjdGVkID0gY3VyclNlbGVjdGVkLmZpbHRlcih2YWx1ZSA9PiB2YWx1ZSAhPT0gcm93S2V5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9uU2VsZWN0KSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IGRhdGFPcGVyYXRvci5nZXRSb3dCeVJvd0lkKGRhdGEsIGtleUZpZWxkLCByb3dLZXkpO1xuICAgICAgICBvblNlbGVjdChyb3csIGNoZWNrZWQsIHJvd0luZGV4LCBlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyBzZWxlY3RlZDogY3VyclNlbGVjdGVkIH0pKTtcbiAgICB9XG5cbiAgICBoYW5kbGVBbGxSb3dzU2VsZWN0ID0gKGUsIGlzVW5TZWxlY3QpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAga2V5RmllbGQsXG4gICAgICAgIHNlbGVjdFJvdzoge1xuICAgICAgICAgIG9uU2VsZWN0QWxsLFxuICAgICAgICAgIG5vblNlbGVjdGFibGVcbiAgICAgICAgfVxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7IHNlbGVjdGVkIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICBsZXQgY3VyclNlbGVjdGVkO1xuXG4gICAgICBpZiAoIWlzVW5TZWxlY3QpIHtcbiAgICAgICAgY3VyclNlbGVjdGVkID0gc2VsZWN0ZWQuY29uY2F0KGRhdGFPcGVyYXRvci5zZWxlY3RhYmxlS2V5cyhkYXRhLCBrZXlGaWVsZCwgbm9uU2VsZWN0YWJsZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VyclNlbGVjdGVkID0gc2VsZWN0ZWQuZmlsdGVyKHMgPT4gdHlwZW9mIGRhdGEuZmluZChkID0+IGRba2V5RmllbGRdID09PSBzKSA9PT0gJ3VuZGVmaW5lZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAob25TZWxlY3RBbGwpIHtcbiAgICAgICAgb25TZWxlY3RBbGwoIWlzVW5TZWxlY3QsIGRhdGFPcGVyYXRvci5nZXRTZWxlY3RlZFJvd3MoZGF0YSwga2V5RmllbGQsIGN1cnJTZWxlY3RlZCksIGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IHNlbGVjdGVkOiBjdXJyU2VsZWN0ZWQgfSkpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxTZWxlY3Rpb25Db250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgdmFsdWU9eyB7XG4gICAgICAgICAgICBzZWxlY3RlZDogdGhpcy5zdGF0ZS5zZWxlY3RlZCxcbiAgICAgICAgICAgIG9uUm93U2VsZWN0OiB0aGlzLmhhbmRsZVJvd1NlbGVjdCxcbiAgICAgICAgICAgIG9uQWxsUm93c1NlbGVjdDogdGhpcy5oYW5kbGVBbGxSb3dzU2VsZWN0XG4gICAgICAgICAgfSB9XG4gICAgICAgID5cbiAgICAgICAgICB7IHRoaXMucHJvcHMuY2hpbGRyZW4gfVxuICAgICAgICA8L1NlbGVjdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIFByb3ZpZGVyOiBTZWxlY3Rpb25Qcm92aWRlcixcbiAgICBDb25zdW1lcjogU2VsZWN0aW9uQ29udGV4dC5Db25zdW1lclxuICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2NvbnRleHRzL3NlbGVjdGlvbi1jb250ZXh0LmpzIiwiLyogZXNsaW50IHJlYWN0L3Byb3AtdHlwZXM6IDAgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCAoXG4gIGRhdGFPcGVyYXRvclxuKSA9PiB7XG4gIGNvbnN0IFJvd0V4cGFuZENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KCk7XG5cbiAgY2xhc3MgUm93RXhwYW5kUHJvdmlkZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcbiAgICAgIGRhdGE6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICAgICAga2V5RmllbGQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZFxuICAgIH1cblxuICAgIHN0YXRlID0geyBleHBhbmRlZDogdGhpcy5wcm9wcy5leHBhbmRSb3cuZXhwYW5kZWQgfHwgW10gfTtcblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICBpZiAobmV4dFByb3BzLmV4cGFuZFJvdykge1xuICAgICAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7XG4gICAgICAgICAgZXhwYW5kZWQ6IG5leHRQcm9wcy5leHBhbmRSb3cuZXhwYW5kZWQgfHwgdGhpcy5zdGF0ZS5leHBhbmRlZFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlUm93RXhwYW5kID0gKHJvd0tleSwgZXhwYW5kZWQsIHJvd0luZGV4LCBlKSA9PiB7XG4gICAgICBjb25zdCB7IGRhdGEsIGtleUZpZWxkLCBleHBhbmRSb3c6IHsgb25FeHBhbmQgfSB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgbGV0IGN1cnJFeHBhbmRlZCA9IFsuLi50aGlzLnN0YXRlLmV4cGFuZGVkXTtcblxuICAgICAgaWYgKGV4cGFuZGVkKSB7XG4gICAgICAgIGN1cnJFeHBhbmRlZC5wdXNoKHJvd0tleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyRXhwYW5kZWQgPSBjdXJyRXhwYW5kZWQuZmlsdGVyKHZhbHVlID0+IHZhbHVlICE9PSByb3dLZXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAob25FeHBhbmQpIHtcbiAgICAgICAgY29uc3Qgcm93ID0gZGF0YU9wZXJhdG9yLmdldFJvd0J5Um93SWQoZGF0YSwga2V5RmllbGQsIHJvd0tleSk7XG4gICAgICAgIG9uRXhwYW5kKHJvdywgZXhwYW5kZWQsIHJvd0luZGV4LCBlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHsgZXhwYW5kZWQ6IGN1cnJFeHBhbmRlZCB9KSk7XG4gICAgfVxuXG4gICAgaGFuZGxlQWxsUm93RXhwYW5kID0gKGUsIGV4cGFuZEFsbCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhLFxuICAgICAgICBrZXlGaWVsZCxcbiAgICAgICAgZXhwYW5kUm93OiB7XG4gICAgICAgICAgb25FeHBhbmRBbGwsXG4gICAgICAgICAgbm9uRXhwYW5kYWJsZVxuICAgICAgICB9XG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHsgZXhwYW5kZWQgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgIGxldCBjdXJyRXhwYW5kZWQ7XG5cbiAgICAgIGlmIChleHBhbmRBbGwpIHtcbiAgICAgICAgY3VyckV4cGFuZGVkID0gZXhwYW5kZWQuY29uY2F0KGRhdGFPcGVyYXRvci5leHBhbmRhYmxlS2V5cyhkYXRhLCBrZXlGaWVsZCwgbm9uRXhwYW5kYWJsZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VyckV4cGFuZGVkID0gZXhwYW5kZWQuZmlsdGVyKHMgPT4gdHlwZW9mIGRhdGEuZmluZChkID0+IGRba2V5RmllbGRdID09PSBzKSA9PT0gJ3VuZGVmaW5lZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAob25FeHBhbmRBbGwpIHtcbiAgICAgICAgb25FeHBhbmRBbGwoZXhwYW5kQWxsLCBkYXRhT3BlcmF0b3IuZ2V0RXhwYW5kZWRSb3dzKGRhdGEsIGtleUZpZWxkLCBjdXJyRXhwYW5kZWQpLCBlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyBleHBhbmRlZDogY3VyckV4cGFuZGVkIH0pKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGtleUZpZWxkIH0gPSB0aGlzLnByb3BzO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPFJvd0V4cGFuZENvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgICB2YWx1ZT17IHtcbiAgICAgICAgICAgIGlzQW55RXhwYW5kczogZGF0YU9wZXJhdG9yLmlzQW55RXhwYW5kcyhkYXRhLCBrZXlGaWVsZCwgdGhpcy5zdGF0ZS5leHBhbmRlZCksXG4gICAgICAgICAgICBleHBhbmRlZDogdGhpcy5zdGF0ZS5leHBhbmRlZCxcbiAgICAgICAgICAgIG9uUm93RXhwYW5kOiB0aGlzLmhhbmRsZVJvd0V4cGFuZCxcbiAgICAgICAgICAgIG9uQWxsUm93RXhwYW5kOiB0aGlzLmhhbmRsZUFsbFJvd0V4cGFuZFxuICAgICAgICAgIH0gfVxuICAgICAgICA+XG4gICAgICAgICAgeyB0aGlzLnByb3BzLmNoaWxkcmVuIH1cbiAgICAgICAgPC9Sb3dFeHBhbmRDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBQcm92aWRlcjogUm93RXhwYW5kUHJvdmlkZXIsXG4gICAgQ29uc3VtZXI6IFJvd0V4cGFuZENvbnRleHQuQ29uc3VtZXJcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb250ZXh0cy9yb3ctZXhwYW5kLWNvbnRleHQuanMiLCJpbXBvcnQgXyBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IEV4dGVuZEJhc2UgPT5cbiAgY2xhc3MgUmVtb3RlUmVzb2x2ZXIgZXh0ZW5kcyBFeHRlbmRCYXNlIHtcbiAgICBnZXROZXdlc3RTdGF0ZSA9IChzdGF0ZSA9IHt9KSA9PiB7XG4gICAgICBsZXQgc29ydE9yZGVyO1xuICAgICAgbGV0IHNvcnRGaWVsZDtcbiAgICAgIGxldCBwYWdlO1xuICAgICAgbGV0IHNpemVQZXJQYWdlO1xuICAgICAgbGV0IHNlYXJjaFRleHQ7XG4gICAgICBsZXQgZmlsdGVycyA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5zb3J0Q29udGV4dCkge1xuICAgICAgICBzb3J0T3JkZXIgPSB0aGlzLnNvcnRDb250ZXh0LnN0YXRlLnNvcnRPcmRlcjtcbiAgICAgICAgc29ydEZpZWxkID0gdGhpcy5zb3J0Q29udGV4dC5zdGF0ZS5zb3J0Q29sdW1uID9cbiAgICAgICAgICB0aGlzLnNvcnRDb250ZXh0LnN0YXRlLnNvcnRDb2x1bW4uZGF0YUZpZWxkIDpcbiAgICAgICAgICBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maWx0ZXJDb250ZXh0KSB7XG4gICAgICAgIGZpbHRlcnMgPSB0aGlzLmZpbHRlckNvbnRleHQuY3VyckZpbHRlcnM7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBhZ2luYXRpb25Db250ZXh0KSB7XG4gICAgICAgIHBhZ2UgPSB0aGlzLnBhZ2luYXRpb25Db250ZXh0LmN1cnJQYWdlO1xuICAgICAgICBzaXplUGVyUGFnZSA9IHRoaXMucGFnaW5hdGlvbkNvbnRleHQuY3VyclNpemVQZXJQYWdlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZWFyY2hDb250ZXh0KSB7XG4gICAgICAgIHNlYXJjaFRleHQgPSB0aGlzLnByb3BzLnNlYXJjaC5zZWFyY2hUZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3J0T3JkZXIsXG4gICAgICAgIHNvcnRGaWVsZCxcbiAgICAgICAgZmlsdGVycyxcbiAgICAgICAgcGFnZSxcbiAgICAgICAgc2l6ZVBlclBhZ2UsXG4gICAgICAgIHNlYXJjaFRleHQsXG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBkYXRhOiB0aGlzLnByb3BzLmRhdGFcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaXNSZW1vdGVTZWFyY2ggPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlbW90ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgIHJldHVybiByZW1vdGUgPT09IHRydWUgfHwgKF8uaXNPYmplY3QocmVtb3RlKSAmJiByZW1vdGUuc2VhcmNoKSB8fCB0aGlzLmlzUmVtb3RlUGFnaW5hdGlvbigpO1xuICAgIH1cblxuICAgIGlzUmVtb3RlUGFnaW5hdGlvbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVtb3RlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgcmV0dXJuIHJlbW90ZSA9PT0gdHJ1ZSB8fCAoXy5pc09iamVjdChyZW1vdGUpICYmIHJlbW90ZS5wYWdpbmF0aW9uKTtcbiAgICB9XG5cbiAgICBpc1JlbW90ZUZpbHRlcmluZyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVtb3RlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgcmV0dXJuIHJlbW90ZSA9PT0gdHJ1ZSB8fCAoXy5pc09iamVjdChyZW1vdGUpICYmIHJlbW90ZS5maWx0ZXIpIHx8IHRoaXMuaXNSZW1vdGVQYWdpbmF0aW9uKCk7XG4gICAgfVxuXG4gICAgaXNSZW1vdGVTb3J0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyByZW1vdGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICByZXR1cm4gcmVtb3RlID09PSB0cnVlIHx8IChfLmlzT2JqZWN0KHJlbW90ZSkgJiYgcmVtb3RlLnNvcnQpIHx8IHRoaXMuaXNSZW1vdGVQYWdpbmF0aW9uKCk7XG4gICAgfVxuXG4gICAgaXNSZW1vdGVDZWxsRWRpdCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVtb3RlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgcmV0dXJuIHJlbW90ZSA9PT0gdHJ1ZSB8fCAoXy5pc09iamVjdChyZW1vdGUpICYmIHJlbW90ZS5jZWxsRWRpdCk7XG4gICAgfVxuXG4gICAgaGFuZGxlUmVtb3RlUGFnZUNoYW5nZSA9IChwYWdlLCBzaXplUGVyUGFnZSkgPT4ge1xuICAgICAgdGhpcy5wcm9wcy5vblRhYmxlQ2hhbmdlKCdwYWdpbmF0aW9uJywgdGhpcy5nZXROZXdlc3RTdGF0ZSh7IHBhZ2UsIHNpemVQZXJQYWdlIH0pKTtcbiAgICB9XG5cbiAgICBoYW5kbGVSZW1vdGVGaWx0ZXJDaGFuZ2UgPSAoZmlsdGVycykgPT4ge1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB7IGZpbHRlcnMgfTtcbiAgICAgIGlmICh0aGlzLmlzUmVtb3RlUGFnaW5hdGlvbigpKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnByb3BzLnBhZ2luYXRpb24ub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgbmV3U3RhdGUucGFnZSA9IF8uaXNEZWZpbmVkKG9wdGlvbnMucGFnZVN0YXJ0SW5kZXgpID8gb3B0aW9ucy5wYWdlU3RhcnRJbmRleCA6IDE7XG4gICAgICB9XG4gICAgICB0aGlzLnByb3BzLm9uVGFibGVDaGFuZ2UoJ2ZpbHRlcicsIHRoaXMuZ2V0TmV3ZXN0U3RhdGUobmV3U3RhdGUpKTtcbiAgICB9XG5cbiAgICBoYW5kbGVSZW1vdGVTb3J0Q2hhbmdlID0gKHNvcnRGaWVsZCwgc29ydE9yZGVyKSA9PiB7XG4gICAgICB0aGlzLnByb3BzLm9uVGFibGVDaGFuZ2UoJ3NvcnQnLCB0aGlzLmdldE5ld2VzdFN0YXRlKHsgc29ydEZpZWxkLCBzb3J0T3JkZXIgfSkpO1xuICAgIH1cblxuICAgIGhhbmRsZVJlbW90ZUNlbGxDaGFuZ2UgPSAocm93SWQsIGRhdGFGaWVsZCwgbmV3VmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGNlbGxFZGl0ID0geyByb3dJZCwgZGF0YUZpZWxkLCBuZXdWYWx1ZSB9O1xuICAgICAgdGhpcy5wcm9wcy5vblRhYmxlQ2hhbmdlKCdjZWxsRWRpdCcsIHRoaXMuZ2V0TmV3ZXN0U3RhdGUoeyBjZWxsRWRpdCB9KSk7XG4gICAgfVxuXG4gICAgaGFuZGxlUmVtb3RlU2VhcmNoQ2hhbmdlID0gKHNlYXJjaFRleHQpID0+IHtcbiAgICAgIHRoaXMucHJvcHMub25UYWJsZUNoYW5nZSgnc2VhcmNoJywgdGhpcy5nZXROZXdlc3RTdGF0ZSh7IHNlYXJjaFRleHQgfSkpO1xuICAgIH1cbiAgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Byb3BzLXJlc29sdmVyL3JlbW90ZS1yZXNvbHZlci5qcyIsImltcG9ydCAqIGFzIHJvd3MgZnJvbSAnLi9yb3dzJztcbmltcG9ydCAqIGFzIHNlbGVjdGlvbiBmcm9tICcuL3NlbGVjdGlvbic7XG5pbXBvcnQgKiBhcyBleHBhbmQgZnJvbSAnLi9leHBhbmQnO1xuaW1wb3J0ICogYXMgbXV0YXRlIGZyb20gJy4vbXV0YXRlJztcbmltcG9ydCAqIGFzIHNvcnQgZnJvbSAnLi9zb3J0JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAuLi5yb3dzLFxuICAuLi5zZWxlY3Rpb24sXG4gIC4uLmV4cGFuZCxcbiAgLi4ubXV0YXRlLFxuICAuLi5zb3J0XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc3RvcmUvb3BlcmF0b3JzLmpzIiwiaW1wb3J0IF8gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgZ2V0Um93QnlSb3dJZCB9IGZyb20gJy4vcm93cyc7XG5cbmV4cG9ydCBjb25zdCBpc0FueUV4cGFuZHMgPSAoXG4gIGRhdGEsXG4gIGtleUZpZWxkLFxuICBleHBhbmRlZCA9IFtdXG4pID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3Qgcm93S2V5ID0gXy5nZXQoZGF0YVtpXSwga2V5RmllbGQpO1xuICAgIGlmICh0eXBlb2YgZXhwYW5kZWQuZmluZCh4ID0+IHggPT09IHJvd0tleSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGNvbnN0IGV4cGFuZGFibGVLZXlzID0gKGRhdGEsIGtleUZpZWxkLCBza2lwcyA9IFtdKSA9PiB7XG4gIGlmIChza2lwcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZGF0YS5tYXAocm93ID0+IF8uZ2V0KHJvdywga2V5RmllbGQpKTtcbiAgfVxuICByZXR1cm4gZGF0YVxuICAgIC5maWx0ZXIocm93ID0+ICFza2lwcy5pbmNsdWRlcyhfLmdldChyb3csIGtleUZpZWxkKSkpXG4gICAgLm1hcChyb3cgPT4gXy5nZXQocm93LCBrZXlGaWVsZCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEV4cGFuZGVkUm93cyA9IChkYXRhLCBrZXlGaWVsZCwgZXhwYW5kZWQpID0+XG4gIGV4cGFuZGVkLm1hcChrID0+IGdldFJvd0J5Um93SWQoZGF0YSwga2V5RmllbGQsIGspKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3N0b3JlL2V4cGFuZC5qcyIsImltcG9ydCBfIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldFJvd0J5Um93SWQgfSBmcm9tICcuL3Jvd3MnO1xuXG5leHBvcnQgY29uc3QgZWRpdENlbGwgPSAoZGF0YSwga2V5RmllbGQsIHJvd0lkLCBkYXRhRmllbGQsIG5ld1ZhbHVlKSA9PiB7XG4gIGNvbnN0IHJvdyA9IGdldFJvd0J5Um93SWQoZGF0YSwga2V5RmllbGQsIHJvd0lkKTtcbiAgaWYgKHJvdykgXy5zZXQocm93LCBkYXRhRmllbGQsIG5ld1ZhbHVlKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zdG9yZS9tdXRhdGUuanMiLCIvKiBlc2xpbnQgbm8tbmVzdGVkLXRlcm5hcnk6IDAgKi9cbi8qIGVzbGludCBuby1sb25lbHktaWY6IDAgKi9cbi8qIGVzbGludCBuby11bmRlcnNjb3JlLWRhbmdsZTogMCAqL1xuaW1wb3J0IF8gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IENvbnN0IGZyb20gJy4uL2NvbnN0JztcblxuZnVuY3Rpb24gY29tcGFyYXRvcihhLCBiKSB7XG4gIGxldCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXN1bHQgPSBiLmxvY2FsZUNvbXBhcmUoYSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gYSA+IGIgPyAtMSA6ICgoYSA8IGIpID8gMSA6IDApO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBjb25zdCBzb3J0ID0gKGRhdGEsIHNvcnRPcmRlciwgeyBkYXRhRmllbGQsIHNvcnRGdW5jIH0pID0+IHtcbiAgY29uc3QgX2RhdGEgPSBbLi4uZGF0YV07XG4gIF9kYXRhLnNvcnQoKGEsIGIpID0+IHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCB2YWx1ZUEgPSBfLmdldChhLCBkYXRhRmllbGQpO1xuICAgIGxldCB2YWx1ZUIgPSBfLmdldChiLCBkYXRhRmllbGQpO1xuICAgIHZhbHVlQSA9IF8uaXNEZWZpbmVkKHZhbHVlQSkgPyB2YWx1ZUEgOiAnJztcbiAgICB2YWx1ZUIgPSBfLmlzRGVmaW5lZCh2YWx1ZUIpID8gdmFsdWVCIDogJyc7XG5cbiAgICBpZiAoc29ydEZ1bmMpIHtcbiAgICAgIHJlc3VsdCA9IHNvcnRGdW5jKHZhbHVlQSwgdmFsdWVCLCBzb3J0T3JkZXIsIGRhdGFGaWVsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzb3J0T3JkZXIgPT09IENvbnN0LlNPUlRfREVTQykge1xuICAgICAgICByZXN1bHQgPSBjb21wYXJhdG9yKHZhbHVlQSwgdmFsdWVCKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGNvbXBhcmF0b3IodmFsdWVCLCB2YWx1ZUEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbiAgcmV0dXJuIF9kYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IG5leHRPcmRlciA9IChcbiAgY3VycmVudFNvcnRDb2x1bW4sXG4gIHsgc29ydE9yZGVyLCBzb3J0Q29sdW1uIH0sXG4gIGRlZmF1bHRPcmRlciA9IENvbnN0LlNPUlRfREVTQ1xuKSA9PiB7XG4gIGlmICghc29ydENvbHVtbiB8fCBjdXJyZW50U29ydENvbHVtbi5kYXRhRmllbGQgIT09IHNvcnRDb2x1bW4uZGF0YUZpZWxkKSByZXR1cm4gZGVmYXVsdE9yZGVyO1xuICByZXR1cm4gc29ydE9yZGVyID09PSBDb25zdC5TT1JUX0RFU0MgPyBDb25zdC5TT1JUX0FTQyA6IENvbnN0LlNPUlRfREVTQztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zdG9yZS9zb3J0LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==
//# sourceMappingURL=react-bootstrap-table-next.js.map